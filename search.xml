<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[各种排序算法总结]]></title>
      <url>http://www.bluestroy.com/2016/09/15/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><img src="http://obmxnha1c.bkt.clouddn.com/21457204_1326898064RUxx.jpg" alt="Untitled Image"><br>稳定的含义：  两个相同元素的相对位置不变。</p>
<hr>
<h3 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1 快速排序"></a>1 快速排序</h3><h5 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h5><blockquote>
<p>①以第一个关键字 K 1 为控制字，将 [K 1 ,K 2 ,…,K n ] 分成两个子区，使左区所有关键字小于等于 K 1 ，右区所有关键字大于等于 K 1 ，最后控制字居两个子区中间的适当位置。在子区内数据尚处于无序状态。<br>②把左区作为一个整体，用①的步骤进行处理，右区进行相同的处理。（即递归）<br>③重复第①、②步，直到左区处理完毕。`  </p>
</blockquote>
<h5 id="1-2-Java实现"><a href="#1-2-Java实现" class="headerlink" title="1.2 Java实现"></a>1.2 Java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//快速排序</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(left&gt;=right)&#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> i = left;</div><div class="line">		<span class="keyword">int</span> j = right;</div><div class="line">		<span class="keyword">int</span> key = a[i];	<span class="comment">//以第一个数为关键字</span></div><div class="line">		<span class="comment">//经过一趟后，关键字在中间的某处，左边的都比其小，右边的都比其大</span></div><div class="line">		<span class="keyword">while</span>(i&lt;j)&#123;</div><div class="line">			<span class="comment">//先从j开始由右往左，遇见比关键字小的则将此数放到左边i的位置，然后i++</span></div><div class="line">			<span class="keyword">while</span>(i&lt;j &amp;&amp; a[j]&gt;=key)&#123;</div><div class="line">				j--;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(i&lt;j)&#123;</div><div class="line">				a[i]=a[j];</div><div class="line">				i++;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//然后再从i开始由左往右，遇见比关键字大的数则将此数放到j的位置，然后j--</span></div><div class="line">			<span class="keyword">while</span>(i&lt;j &amp;&amp; a[i]&lt;=key)&#123;</div><div class="line">				i++;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(i&lt;j)&#123;</div><div class="line">				a[j]=a[i];</div><div class="line">				j--;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		a[i]=key;</div><div class="line">		<span class="comment">//然后对左右区间分别执行快排算法</span></div><div class="line">		quickSort(a,left,i-<span class="number">1</span>);</div><div class="line">		quickSort(a,i+<span class="number">1</span>,right);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h5 id="1-3-算法分析"><a href="#1-3-算法分析" class="headerlink" title="1.3 算法分析"></a>1.3 算法分析</h5><p>每次分成两组，分logn次，每趟比较n次。<br><strong>时间复杂度</strong>： O(nlogn)<br><strong>最坏情况</strong>：O(n^2)<br><strong>空间复杂度</strong>：O(nlogn)<br><strong>不稳定</strong></p>
<h3 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2 冒泡排序"></a>2 冒泡排序</h3><p>按从小到达排序：</p>
<h5 id="2-1-思路"><a href="#2-1-思路" class="headerlink" title="2.1 思路"></a>2.1 思路</h5><blockquote>
<ol>
<li>按从前往后的顺序多次扫描，每次扫描向后比较相邻元素，若后面比前面小，则交换它们</li>
<li>第一趟扫描完后，最后一个元素应该是最大的数</li>
<li>同理扫描前n-1个数，第二次扫描第二大元素则变为倒数第二个位置</li>
<li>以此类推</li>
</ol>
</blockquote>
<h5 id="2-2-Java实现"><a href="#2-2-Java实现" class="headerlink" title="2.2 Java实现"></a>2.2 Java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">        <span class="comment">//n个数，进行n-1次扫描</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="comment">//每次扫描都比较前i个数，每两个相邻的数，将小的放前面</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</div><div class="line">                    temp = a[j];</div><div class="line">                    a[j] = a[j + <span class="number">1</span>];</div><div class="line">                    a[j + <span class="number">1</span>] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="2-3-算法分析"><a href="#2-3-算法分析" class="headerlink" title="2.3 算法分析"></a>2.3 算法分析</h5><p>感觉冒泡排序交换次数太多，用的比较少<br><strong>时间复杂度</strong>： O(n^2)<br><strong>最坏情况</strong>：O(n^2)<br><strong>最好</strong>：O(n)<br><strong>空间复杂度</strong>：O(1)<br><strong>稳定</strong></p>
<h3 id="3-直接选择排序"><a href="#3-直接选择排序" class="headerlink" title="3 直接选择排序"></a>3 直接选择排序</h3><h5 id="3-1-思路"><a href="#3-1-思路" class="headerlink" title="3.1 思路"></a>3.1 思路</h5><blockquote>
<p>每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法</p>
<h5 id="3-2-Java实现"><a href="#3-2-Java实现" class="headerlink" title="3.2 Java实现"></a>3.2 Java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> min = <span class="number">0</span>,temp = <span class="number">0</span>;</div><div class="line">        <span class="comment">//进行n次扫描</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</div><div class="line">            min = i;</div><div class="line">            <span class="comment">//每一次扫描取出待排序中最小的元素</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (a[min] &gt; a[j]) &#123;</div><div class="line">                    min = j;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//将该最小的元素放到待排序序列的第一个位置</span></div><div class="line">            <span class="keyword">if</span> (min != i) &#123;</div><div class="line">                temp = a[min];</div><div class="line">                a[min] = a[i];</div><div class="line">                a[i] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-3-算法分析"><a href="#3-3-算法分析" class="headerlink" title="3.3 算法分析"></a>3.3 算法分析</h5><p><strong>时间复杂度</strong>： O(n^2)<br><strong>最坏情况</strong>：O(n^2)<br><strong>空间复杂度</strong>：O(1)<br><strong>不稳定</strong></p>
<h3 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4 堆排序"></a>4 堆排序</h3><p>以大根堆为例：</p>
<h5 id="4-1-思路"><a href="#4-1-思路" class="headerlink" title="4.1 思路"></a>4.1 思路</h5><blockquote>
<ol>
<li>将一个无序数列建成一个初始堆</li>
<li>输出堆顶元素并调整剩余元素成为一个新堆</li>
<li>重复1和2，则最终按顺序输出的数列即为排好序的数列</li>
</ol>
</blockquote>
<h6 id="4-2-构建初始堆"><a href="#4-2-构建初始堆" class="headerlink" title="4.2 构建初始堆"></a>4.2 构建初始堆</h6><ol>
<li>首先数列构造一个完全二叉树。  </li>
<li>n为下标，从0开始。则最后一个非叶节点下标x是[n/2]向下取整，故从x处从后往前进行调整。  </li>
<li>每次比较父节点、左孩子、右孩子，将最小的孩子与父节点交换。</li>
<li>每次交换后需对被交换的孩子节点进行调整  </li>
</ol>
<h5 id="4-3-Java实现"><a href="#4-3-Java实现" class="headerlink" title="4.3 Java实现"></a>4.3 Java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调整堆</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="comment">//start和end分别为【初始下标】和【结束下标】</span></div><div class="line">        <span class="keyword">int</span> temp;</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        <span class="keyword">for</span>(; <span class="number">2</span>*start+<span class="number">1</span> &lt;= end;start=i)&#123;</div><div class="line">            i=<span class="number">2</span>*start+<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(i &lt; end &amp;&amp; a[i] &lt; a[i+<span class="number">1</span>])&#123;</div><div class="line">                i++;  <span class="comment">//i为较大孩子节点的下标</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(a[start] &lt; a[i])&#123; <span class="comment">//左右孩子中获胜者与父亲比较</span></div><div class="line">                <span class="comment">//将孩子结点上位，则以孩子结点的位置进行下一轮的筛选</span></div><div class="line">                temp = a[start];</div><div class="line">                a[start]=a[i];</div><div class="line">                a[i] = temp;</div><div class="line"><span class="comment">//                start = i;</span></div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="comment">//因为整棵树是从下往上调整数，所以，若父节点不需要调整，说明该节点子树已满足堆性质，跳出循环</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//堆排序</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;   <span class="comment">//从最后一个非叶节点开始，建立初始堆</span></div><div class="line">            heapAdjust(a,i,a.length-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//进行排序</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =a.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;--i)&#123;</div><div class="line">            <span class="comment">//将待排序区最后一个元素和第一个元素进行交换</span></div><div class="line">            <span class="keyword">int</span> temp =a[i];</div><div class="line">            a[i]=a[<span class="number">0</span>];</div><div class="line">            a[<span class="number">0</span>]=temp;</div><div class="line">            <span class="comment">//将剩下的无序元素调整为大顶堆</span></div><div class="line">            heapAdjust(a,<span class="number">0</span>,i-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 算法分析</h5><p><strong>时间复杂度</strong>： O(nlogn)<br><strong>最坏情况</strong>：O(nlogn)<br><strong>空间复杂度</strong>：O(1)<br><strong>不稳定</strong></p>
<blockquote>
<p><strong>堆排序方法对记录数较少的文件并不值得提倡，但对n较大的文件还是很有效的</strong>。因为其运行时间主要耗费在建初始堆和调整建新堆时进行的反复“筛选”上。<br>堆排序在最坏的情况下，其时间复杂度也为O(nlogn)。相对于快速排序来说，这是堆排序的最大优点。此外，堆排序仅需一个记录大小的供交换用的辅助存储空间。</p>
</blockquote>
<h3 id="5-直接插入排序"><a href="#5-直接插入排序" class="headerlink" title="5 直接插入排序"></a>5 直接插入排序</h3><h5 id="5-1-思路"><a href="#5-1-思路" class="headerlink" title="5.1 思路"></a>5.1 思路</h5><ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到下一位置中</li>
<li>重复步骤2~5<h5 id="5-2-Java实现"><a href="#5-2-Java实现" class="headerlink" title="5.2 Java实现"></a>5.2 Java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//直接插入排序</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="comment">//遍历数组</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;a.length;i++)&#123;</div><div class="line">            temp = a[i]; <span class="comment">//将待排序的第一个元素放到监视哨中，作为要插入的数</span></div><div class="line">            j=i-<span class="number">1</span>;  <span class="comment">//从后往前开始查找的位置j</span></div><div class="line">            <span class="keyword">while</span>(j&gt;-<span class="number">1</span> &amp;&amp; temp &lt; a[j])&#123;</div><div class="line">                a[j+<span class="number">1</span>]=a[j];    <span class="comment">//将大于该数的右移</span></div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            a[j+<span class="number">1</span>]=temp;  <span class="comment">//最终找到插入位置为j+1</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="5-3-算法分析"><a href="#5-3-算法分析" class="headerlink" title="5.3 算法分析"></a>5.3 算法分析</h5><p>感觉直接插入排序的移动次数太多，效率也不高<br><strong>时间复杂度</strong>： O(n^2)<br><strong>最坏情况</strong>：O(n^2)<br><strong>最好</strong>： O(n)<br><strong>空间复杂度</strong>：O(1)<br><strong>稳定</strong></p>
<h3 id="6-希尔（shell）排序"><a href="#6-希尔（shell）排序" class="headerlink" title="6 希尔（shell）排序"></a>6 希尔（shell）排序</h3><h5 id="6-1-思路"><a href="#6-1-思路" class="headerlink" title="6.1 思路"></a>6.1 思路</h5><blockquote>
<ol>
<li>先取一个正整数d1&lt;n，把所有序号相隔d1的数组元素放一组，组内进行<strong>直接插入排序</strong></li>
<li>然后取d2&lt;d1，重复上述分组和排序操作</li>
<li>直至di=1，即所有记录放进一个组中排序为止<h5 id="6-2-Java实现"><a href="#6-2-Java实现" class="headerlink" title="6.2 Java实现"></a>6.2 Java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//希尔排序</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> d=a.length/<span class="number">2</span>; <span class="comment">//初始步长</span></div><div class="line">        <span class="keyword">while</span>(d&gt;=<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;d;x++)&#123;   <span class="comment">//一共有x组</span></div><div class="line">                <span class="comment">//对每一组进行直接插入排序</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=x+d;i&lt;a.length;i+=d)&#123;</div><div class="line">                    <span class="keyword">int</span> temp = a[i];</div><div class="line">                    <span class="keyword">int</span> j=i-d;</div><div class="line">                    <span class="keyword">while</span>(j&gt;x-<span class="number">1</span> &amp;&amp; temp&lt;a[j])&#123;</div><div class="line">                        a[j+d] = a[j];</div><div class="line">                        j-=d;</div><div class="line">                    &#125;</div><div class="line">                    a[j+d]=temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            d=d/<span class="number">2</span>;  <span class="comment">//缩短步长</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h5 id="6-3-算法分析"><a href="#6-3-算法分析" class="headerlink" title="6.3 算法分析"></a>6.3 算法分析</h5><p><strong>时间复杂度</strong>： O(n^1.3)<br><strong>最坏情况</strong>：O(n^2)<br><strong>最好</strong>： O(n)<br><strong>空间复杂度</strong>：O(1)<br><strong>不稳定</strong></p>
<h3 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7 归并排序"></a>7 归并排序</h3><h5 id="7-1-思路"><a href="#7-1-思路" class="headerlink" title="7.1 思路"></a>7.1 思路</h5><blockquote>
<ol>
<li>将序列每相邻两个数字进行归并操作（merge)，形成floor(n/2)个序列，排序后每个序列包含两个元素  </li>
<li>将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素  </li>
<li>重复步骤2，直到所有元素排序完毕<br><strong>&lt; 超优美的递归 &gt;</strong></li>
</ol>
<p>如:<br>设有数列{6，202，100，301，38，8，1}<br>初始状态：6，202，100，301，38，8，1<br>第一次归并后：{6，202}，{100，301}，{8，38}，{1}，比较次数：3；<br>第二次归并后：{6，100，202，301}，{1，8，38}，比较次数：4；<br>第三次归并后：{1，6，8，38，100，202，301}，比较次数：4；<br>总的比较次数为：3+4+4=11，<br>逆序数为14。</p>
<h5 id="7-2-Java实现"><a href="#7-2-Java实现" class="headerlink" title="7.2 Java实现"></a>7.2 Java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 二路归并</div><div class="line"> * <span class="doctag">@param</span> a 要归并的数组</div><div class="line"> * <span class="doctag">@param</span> startIndex 要归并数组的起始下标-即第一个子序列的开始下标</div><div class="line"> * <span class="doctag">@param</span> midIndex 要归并数组的中点下标-即第二个子序列的开始下标</div><div class="line"> * <span class="doctag">@param</span> endIndex 要归并数组的终点下标</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> startIndex, <span class="keyword">int</span> midIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = startIndex; <span class="comment">//第一个序列的下标</span></div><div class="line">    <span class="keyword">int</span> j = midIndex +<span class="number">1</span>;<span class="comment">//第二个序列的下标</span></div><div class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;   <span class="comment">// k是临时数组的下标</span></div><div class="line">    <span class="keyword">int</span> [] array = <span class="keyword">new</span> <span class="keyword">int</span>[endIndex-startIndex+<span class="number">1</span>]; <span class="comment">//临时合并数组</span></div><div class="line">    <span class="comment">//每次取出两个序列中的小者，将其放到合并数组中（两个子序列已时排好序的）</span></div><div class="line">    <span class="keyword">while</span>(i&lt;=midIndex &amp;&amp; j&lt;=endIndex)&#123;</div><div class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])&#123;</div><div class="line">            array[k] = a[i];</div><div class="line">            i++;k++;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            array[k]=a[j];</div><div class="line">            j++;k++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//若第一个序列没扫描完，则将其全部复制到合并数组</span></div><div class="line">    <span class="keyword">while</span> (i&lt;=midIndex)&#123;</div><div class="line">        array[k] = a[i];</div><div class="line">        i++;k++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//若第二个序列没扫描完，则将其全部复制到合并数组</span></div><div class="line">    <span class="keyword">while</span> (j&lt;=endIndex)&#123;</div><div class="line">        array[k] = a[j];</div><div class="line">        j++;k++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//将合并数组复制到原序列中</span></div><div class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>,i=startIndex;i&lt;=endIndex;i++,k++)&#123;</div><div class="line">        a[i] = array[k];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 归并排序，内部使用递归，太优美了</div><div class="line"> * <span class="doctag">@param</span> a 要排序的数组</div><div class="line"> * <span class="doctag">@param</span> startIndex 要排序的起始下标</div><div class="line"> * <span class="doctag">@param</span> endIndex 要排序的终点下标</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> midIndex;</div><div class="line">    <span class="keyword">if</span>(startIndex &lt; endIndex)&#123;</div><div class="line">        midIndex = (startIndex+endIndex)/<span class="number">2</span>;</div><div class="line">        mergeSort(a, startIndex, midIndex);</div><div class="line">        mergeSort(a, midIndex+<span class="number">1</span>, endIndex);</div><div class="line">        merge(a,startIndex,midIndex,endIndex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<h5 id="7-3-算法分析"><a href="#7-3-算法分析" class="headerlink" title="7.3 算法分析"></a>7.3 算法分析</h5><p><strong>时间复杂度</strong>： O(nlogn)<br><strong>最坏情况</strong>：O(nlogn)<br><strong>最好</strong>： O(nlogn)<br><strong>空间复杂度</strong>：O(1)<br><strong>稳定</strong></p>
<hr>
<p><strong><em>以上所有，都应深深地印在脑子里。  </em></strong></p>
<p><img src="http://obmxnha1c.bkt.clouddn.com/21457204_1326898064RUxx.jpg" alt="Untitled Image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于数据结构的小知识]]></title>
      <url>http://www.bluestroy.com/2016/09/15/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h4 id="二叉树的深度和高度"><a href="#二叉树的深度和高度" class="headerlink" title="二叉树的深度和高度"></a>二叉树的深度和高度</h4><p>树的深度是从根节点开始（其深度为1）自顶向下逐层累加的，而高度是从叶节点开始（其高度为1）自底向上逐层累加的。  </p>
<p>二叉树的深度h即为二叉树的层数，二叉树最多含有节点数为 2^h-1。</p>
<h4 id="完全二叉树："><a href="#完全二叉树：" class="headerlink" title="完全二叉树："></a>完全二叉树：</h4><p>只有最下面两层节点度能够小于2，并且最下面一层的节点都集中在该层最左边的若干位置的二叉树。</p>
<p>若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是<strong>完全二叉树</strong>。  </p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>除叶子节点外的所有节点均有两个子节点，即节点数达到最大值。 2^h-1<br><strong>叶子数：</strong> 2^h<br><strong>第k层节点数：</strong> 2^(k-1)<br><strong>总结点数：</strong> 2^k-1</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>Ki(i从0开始）。 则Ki的左孩子为K(2i+1)，右孩子K(2i+2)。父节点为Parent(i)=K[(i-1)/2]  </p>
<p><strong>小根堆：</strong> K[i]&lt;=K[2i+1] &amp;&amp; K[i]&lt;=K[2i+2]<br><strong>大根堆：</strong> K[i]&gt;=K[2i+1] &amp;&amp; K[i]&gt;=K[2i+2]  </p>
<p>空间复杂度：O(1)，建堆复杂度O(n)，调整堆的复杂度O(nlogn)</p>
<h4 id="各种排序算法复杂度"><a href="#各种排序算法复杂度" class="headerlink" title="各种排序算法复杂度"></a>各种排序算法复杂度</h4><p><img src="http://blog.chinaunix.net/attachment/201201/18/21457204_1326898064RUxx.jpg" alt="各种排序算法复杂度"></p>
<h4 id="死锁的4个必要条件"><a href="#死锁的4个必要条件" class="headerlink" title="死锁的4个必要条件"></a>死锁的4个必要条件</h4><p>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不可抢占（不剥夺）条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。  </p>
<h4 id="标准的SQL解析顺序"><a href="#标准的SQL解析顺序" class="headerlink" title="标准的SQL解析顺序"></a>标准的SQL解析顺序</h4><p>(1).FROM 子句, 组装来自不同数据源的数据<br>(2).WHERE 子句, 基于指定的条件对记录进行筛选<br>(3).GROUP BY 子句, 将数据划分为多个分组<br>(4).使用聚合函数进行计算<br>(5).使用 HAVING 子句筛选分组<br>(6).计算Select所有的表达式<br>(7).使用 ORDER BY 对结果集进行排序  </p>
<h4 id="简述abstract-类和interface的区别"><a href="#简述abstract-类和interface的区别" class="headerlink" title="简述abstract 类和interface的区别"></a>简述abstract 类和interface的区别</h4><p>同： abstract类 和接口都可以有abstract方法<br>不同：  </p>
<ol>
<li><p>接口中只可以有常量，不能有变量；而abstract类中既可以有常量也可以有变量  </p>
</li>
<li><p>abstract类也可以有非abstract方法，接口不可以。  </p>
</li>
<li>实现接口是一定要实现接口里定义的所有方法，而实现抽象类可以有选择的重写需要用到的方法。  </li>
<li>接口是公开的，里面不能有私有的方法和变量。而首次昂类是可以有私有方法和私有变量的。  </li>
<li>Java抽象类可以提供某些方法的部分实现，而Java接口不可以（就是interface中只能定义方法，而不能有方法的实现，而在abstract class中则可以既有方法的具体实现，又有没有具体实现的抽象方法）  </li>
<li>子类只能单继承抽象类；而子类能够同时实现多个接口</li>
</ol>
<h4 id="java中对象什么时候被垃圾回收"><a href="#java中对象什么时候被垃圾回收" class="headerlink" title="java中对象什么时候被垃圾回收"></a>java中对象什么时候被垃圾回收</h4><p>当没有任何对象的引用指向对象时，在一个不可预期的时间内对象才会被回收  </p>
<p>当对象的引用为空，当对象堆当前使用这个对象的应用程序不可触及的时候，这个对象就可以被回收了。</p>
<blockquote>
<p>一个对象，可以有一个或多个引用变量指向它。当一个对象不再有任何一个引用变量指向它时，这个对象就被应用抛弃了。或者说，这个对象可以被垃圾回收机制回收了。这就是说，当不存在对某对象的任何引用时，就意味着，应用告诉JVM：我不要这个对象，你可以回收了。  </p>
<p>JVM的垃圾回收机制对堆空间做实时检测。当发现某对象的引用计数为0时，就将该对象列入待回收列表中。但是，并不是马上予以销毁</p>
</blockquote>
<h4 id="计算1！-2！-……-n-（最简单的单循环方法）"><a href="#计算1！-2！-……-n-（最简单的单循环方法）" class="headerlink" title="计算1！+2！+……+n!（最简单的单循环方法）"></a>计算1！+2！+……+n!（最简单的单循环方法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> n;</div><div class="line">		<span class="keyword">long</span> sum =<span class="number">0</span>;</div><div class="line">		<span class="keyword">long</span> temp =<span class="number">1</span>;</div><div class="line">		Scanner cin = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">		n = cin.nextInt();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">			temp*=i;	</div><div class="line">			sum+=temp;</div><div class="line">		&#125;</div><div class="line">		System.out.println(sum);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> s_id,c_id,score</div><div class="line"><span class="keyword">from</span> grade</div><div class="line"><span class="keyword">where</span> score&gt;<span class="number">80</span>;</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> s_name,c_id,score</div><div class="line"><span class="keyword">from</span> grade,student</div><div class="line"><span class="keyword">where</span> score&gt;<span class="number">80</span> <span class="keyword">and</span> grade.s_id = student.s_id;</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> s_name,c_name,score</div><div class="line"><span class="keyword">from</span> student,course,grade</div><div class="line"><span class="keyword">where</span> score <span class="keyword">is</span> <span class="literal">NULL</span> <span class="keyword">and</span> student.s_id = grade.s_id <span class="keyword">and</span> course.c_id = grade.c_id;</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> s_id</div><div class="line"><span class="keyword">from</span> grade </div><div class="line"><span class="keyword">where</span> <span class="keyword">min</span>(score) &gt;<span class="number">80</span></div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> s_id;</div></pre></td></tr></table></figure>
<p>列出学生及格和不及格的科目数，栏位包括学生号、及格科目数、不及格科目数：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> a.s_id, <span class="keyword">count</span>(a), <span class="keyword">count</span>(b)</div><div class="line"><span class="keyword">from</span> grade <span class="keyword">as</span> a,</div><div class="line">	(<span class="keyword">select</span> s_id <span class="keyword">from</span> grade <span class="keyword">where</span> score &lt; <span class="number">60</span>) <span class="keyword">as</span> b </div><div class="line"><span class="keyword">where</span> a.score&gt;<span class="number">60</span> <span class="keyword">and</span> a.s_id = b.s_id </div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> s_id;</div></pre></td></tr></table></figure></p>
<h4 id="Java单例模式"><a href="#Java单例模式" class="headerlink" title="Java单例模式"></a>Java单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 懒汉模式，线程不安全</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance =<span class="keyword">null</span>;</div><div class="line">   	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    	<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">        	instance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//懒汉模式 线程安全</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance =<span class="keyword">null</span>;</div><div class="line">   	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    	<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">        	instance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//懒汉模式 线程安全优化</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance =<span class="keyword">null</span>;</div><div class="line">   	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    	<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">        	<span class="keyword">synchronized</span>(Singleton.class)&#123;</div><div class="line">            	<span class="keyword">if</span>(instance ==<span class="keyword">null</span>)&#123;</div><div class="line">                	instance = <span class="keyword">new</span> Singleton();</div><div class="line">            	&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 饿汉模式，无线程安全问题</span></div><div class="line"> * 缺点是类一加载就实例化，提前占用系统资源。</div><div class="line"> * 但实际可能并没有用到</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">   	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="在3亿个数中找出不重复的整数，假设电脑内存之后2G"><a href="#在3亿个数中找出不重复的整数，假设电脑内存之后2G" class="headerlink" title="在3亿个数中找出不重复的整数，假设电脑内存之后2G"></a>在3亿个数中找出不重复的整数，假设电脑内存之后2G</h4><p>待回答。</p>
<h4 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h4><p>待回答。</p>
<h4 id="数据库的基本锁有哪几种，脏读是如何产生的"><a href="#数据库的基本锁有哪几种，脏读是如何产生的" class="headerlink" title="数据库的基本锁有哪几种，脏读是如何产生的"></a>数据库的基本锁有哪几种，脏读是如何产生的</h4><p>待回答。</p>
<h4 id="系统平均无故障时间——可靠性。X个9的含义"><a href="#系统平均无故障时间——可靠性。X个9的含义" class="headerlink" title="系统平均无故障时间——可靠性。X个9的含义"></a>系统平均无故障时间——可靠性。X个9的含义</h4><p>参考 <a href="http://blog.csdn.net/alonesword/article/details/21555745" target="_blank" rel="external">什么是“5个9”(99.999%)的可靠性？</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux常用命令]]></title>
      <url>http://www.bluestroy.com/2016/09/12/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="一、crontab简介"><a href="#一、crontab简介" class="headerlink" title="一、crontab简介"></a>一、crontab简介</h3><p>crontab命令常见于Unix和类Unix系统中，用于设置周期性被执行的命令。该命令从标准输入设备读取指令，并将其存放在<code>crontab</code>文件中，以供之后读取和执行。 </p>
<h5 id="1、crontab调度文件规则"><a href="#1、crontab调度文件规则" class="headerlink" title="1、crontab调度文件规则"></a>1、crontab调度文件规则</h5><p>命令格式：<code>* * * * * command</code><br><strong>*</strong> 依次表示<strong>分钟、小时、日、月、星期</strong>  </p>
<ul>
<li>分钟——每小时的第几分钟执行，范围0~59  </li>
<li>小时——每日的第几个小时执行，范围0~23</li>
<li>日——每月的第几天执行，范围1~31  </li>
<li>月——每年你的第几月执行 ，范围1~12  </li>
<li>星期——每周的第几天执行，范围0~6  </li>
</ul>
<h5 id="2、crontab命令的例子"><a href="#2、crontab命令的例子" class="headerlink" title="2、crontab命令的例子"></a>2、crontab命令的例子</h5><p><strong>*</strong> 表示该范围内任意时候，如每分钟执行一次：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* * * * * date &gt; /home/mydate</div></pre></td></tr></table></figure>
<p>每天晚上11点到早上8点之间每两个小时，即早上八点 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 23-7/2 * * * date</div></pre></td></tr></table></figure></p>
<p>每两个小时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 */2 * * * date</div></pre></td></tr></table></figure></p>
<p>每个月的4号和每周的周一到周三的早上11点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 11 4 * mon-wed date</div></pre></td></tr></table></figure></p>
<p>每天18 : 00至23 : 00之间每隔30分钟重启apache：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0,30 18-23 * * * /usr/local/etc/rc.d/lighttpd restart</div></pre></td></tr></table></figure></p>
<h5 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">crontab -r <span class="comment">#停止（即删除）所有任务（慎用）</span></div><div class="line">crontab <span class="_">-l</span> <span class="comment">#列出所有任务</span></div></pre></td></tr></table></figure>
<h3 id="二、文件中-atime-ctime-mtime简介"><a href="#二、文件中-atime-ctime-mtime简介" class="headerlink" title="二、文件中 -atime, -ctime, -mtime简介"></a>二、文件中 -atime, -ctime, -mtime简介</h3><ul>
<li>atime(Access time)，访问时间，如读取文件</li>
<li>ctime(Change time), 状态时间，如修改权限、属性、所有者</li>
<li>mtime(Modified time), 修改时间，文件内容修改的时间<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">find . -mtime +3 <span class="comment">#3天以前修改的文件(&gt;3)  </span></div><div class="line">find . -mtime -3 <span class="comment">#3天之内修改的文件(&lt;3)</span></div><div class="line">find . -mtime 1 <span class="comment">#距离当前时间24~24*2小时内修改的文件(即当前时间的“昨天内”）</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="三、-amin-cmin-mmin简介"><a href="#三、-amin-cmin-mmin简介" class="headerlink" title="三、-amin, -cmin, -mmin简介"></a>三、-amin, -cmin, -mmin简介</h3><p>与atime，ctime，mtime用法相同，只不过time表示天，min表示分钟</p>
<h3 id="四、history命令"><a href="#四、history命令" class="headerlink" title="四、history命令"></a>四、history命令</h3><p>显示最近使用的5个命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">history</span> 5</div></pre></td></tr></table></figure></p>
<p>执行历史编号为5的命令那个：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ !5</div></pre></td></tr></table></figure></p>
<p>执行最后一次以ls结尾的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ !ls</div></pre></td></tr></table></figure></p>
<h3 id="五、为bash脚本设置别名"><a href="#五、为bash脚本设置别名" class="headerlink" title="五、为bash脚本设置别名"></a>五、为bash脚本设置别名</h3><p>修改<code>~/.bashrc</code>文件，该文件是登录用户的启动文件，能用作用户的全局设置。<br>假定在/opt/fashion/目录下编写了某一键部署的bash脚本命令文件<code>deploy.sh</code>，则在<code>~./bashrc</code>文件中添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias go=&apos;/opt/fashion/deploy.sh&apos;</div></pre></td></tr></table></figure></p>
<p>那么在命令行中直接执行<code>go</code>命令即可执行<code>deploy.sh</code>文件中的命令。  </p>
<p>注意：编辑完后执行<code>source ./bashrc</code>命令使其生效，若不能生效则重新登录生效。  </p>
<h3 id="六、usermod将用户添加到用户组"><a href="#六、usermod将用户添加到用户组" class="headerlink" title="六、usermod将用户添加到用户组"></a>六、usermod将用户添加到用户组</h3><p>千万不能直接用 <code>usermode -G groupName userName</code>，这样做会使你离开其他用户组，仅仅作为用户组groupName的成员。<br>应该加上<code>-a</code>选项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ usermod <span class="_">-a</span> -G sudo userName</div></pre></td></tr></table></figure></p>
<p>-a代表append，也就是将用户添加到用户组sudo中，而不必离开其他用户组。  </p>
<h3 id="七、head-和tail"><a href="#七、head-和tail" class="headerlink" title="七、head 和tail"></a>七、head 和tail</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">head -n 20 /etc/man.config <span class="comment">#列出前20行</span></div><div class="line">head -n -100 /etc/man.config <span class="comment">#列出除最后100行的之前的所有行  </span></div><div class="line">tail -n 20 /etc/ <span class="comment">#列出最后20行  </span></div><div class="line">tail -n +100 /etc/man.config <span class="comment">#列出除前100行的之后的所有行  </span></div><div class="line">head -n 20 /etc/man.config | tail -n 10 <span class="comment">#显示第11到20行</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux中mysql数据库定时备份]]></title>
      <url>http://www.bluestroy.com/2016/09/12/Linux%E4%B8%ADmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD/</url>
      <content type="html"><![CDATA[<h4 id="Linux中，为mysql数据库备份，并删除一个月以前的备份数据"><a href="#Linux中，为mysql数据库备份，并删除一个月以前的备份数据" class="headerlink" title="Linux中，为mysql数据库备份，并删除一个月以前的备份数据"></a>Linux中，为mysql数据库备份，并删除一个月以前的备份数据</h4><p>mysql_backup.sh备份脚本命令如下：</p>
<pre><code class="bash"><span class="meta">#! /bin/bash</span>
<span class="comment"># 按照时间戳来命名备份数据，便于管理</span>
DATE=`date+%Y-%m-%d-%H:%M:%S`  
mysqldump -u root -p123456 mysqldbName &gt; /mysql_backup/backdata/mysqldbName_<span class="variable">${DATE}</span>.bak  
<span class="comment"># 删除30天以前的备份数据</span>
find /mysql_backup/backdata/ -atime +30 | xargs rm
</code></pre>
<p>其中root是mysql用户，123456是用户密码，msyqldbName是数据库名字，该备份命令会将mysqldbName数据库的数据全部备份到/mysql<em>backup/backdata目录下，并以mysqldbName\</em>加上时间戳的形式命名。 </p>
<h4 id="crontab定时备份任务"><a href="#crontab定时备份任务" class="headerlink" title="crontab定时备份任务"></a>crontab定时备份任务</h4><p>将mysql_backup.sh脚本文件的执行加入到crontab定时任务中，编辑crontab定时任务:</p>
<pre><code class="bash">$ crontab <span class="_">-e</span>
</code></pre>
<p>将一下内容追加到crontab文件中：</p>
<pre><code class="bash">0 12 * * * /mysql_backup/mysql_backup.sh
0 0 * * * /mysql_backup/mysql_backup.sh
</code></pre>
<p>第一行内容表示每天中午12点执行mysql_backup.sh中的备份命令，第二行表示每天凌晨执行备份命令。你可以在任意时候执行备份命令，只需要学习一下crontab的 <em> </em> <em> </em> * 分别代表什么意思就可以。  </p>
<h4 id="mysql数据库恢复备份数据"><a href="#mysql数据库恢复备份数据" class="headerlink" title="mysql数据库恢复备份数据"></a>mysql数据库恢复备份数据</h4><pre><code class="bash">$ mysql -u root -p123456 mysqldbName &lt; /mysql_backup/backdata/mysqldbName_xxxxxx.bak
</code></pre>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java实现通过smtp服务器验证邮箱的真实有效性]]></title>
      <url>http://www.bluestroy.com/2016/09/10/Java%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%BF%87smtp%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AA%8C%E8%AF%81%E9%82%AE%E7%AE%B1%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%9C%89%E6%95%88%E6%80%A7/</url>
      <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>设置一个已有邮箱地址，通过向邮箱服务器发送一个请求，去与目标邮箱地址通信，根据邮箱服务器的返回结果来判断目标邮箱地址是否是真实有效的邮箱。  </p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>该程序要用到commons-net-3.3.jar、dnsjava-2.1.7.jar包</li>
<li>大部分的国内常见邮箱都能准确验证</li>
<li>验证频率和数量多的话容易被封掉ip</li>
<li>使用了”no-reply@domain.com”作为发送邮箱，不要用自己使用的邮箱作为程序的发送邮箱，验证频率和数量多的话邮箱地址容易被封  </li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="java"><span class="keyword">package</span> com.tieniu;
<span class="keyword">import</span> java.io.IOException;

<span class="keyword">import</span> org.apache.commons.net.smtp.SMTPClient;
<span class="keyword">import</span> org.apache.commons.net.smtp.SMTPReply;
<span class="keyword">import</span> org.xbill.DNS.Lookup;
<span class="keyword">import</span> org.xbill.DNS.MXRecord;
<span class="keyword">import</span> org.xbill.DNS.Record;
<span class="keyword">import</span> org.xbill.DNS.Type;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckEmail</span> </span>{

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SENDER_EMAIL = <span class="string">"no-reply@domain.com"</span>;<span class="comment">//"no-reply@domain.com";</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SENDER_EMAIL_SERVER = SENDER_EMAIL.split(<span class="string">"@"</span>)[<span class="number">1</span>];<span class="comment">//"domain.com";</span>


    <span class="comment">/**
     * 
     * <span class="doctag">@param</span> email  The recipient's email address, it need to be validate if it is real exists or doesn't exists.
     * <span class="doctag">@return</span> True if email is real exists, false if not.
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkEmailMethod</span><span class="params">(String email)</span> </span>{
        <span class="keyword">if</span> (!email.matches(<span class="string">"[\\w\\.\\-]+@([\\w\\-]+\\.)+[\\w\\-]+"</span>)) {
            System.err.println(<span class="string">"Format error"</span>);
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }

        String log = <span class="string">""</span>;
        String host = <span class="string">""</span>;
        String hostName = email.split(<span class="string">"@"</span>)[<span class="number">1</span>];
        Record[] result = <span class="keyword">null</span>;
        SMTPClient client = <span class="keyword">new</span> SMTPClient();
        client.setConnectTimeout(<span class="number">8000</span>);  <span class="comment">//设置连接超时时间,有些服务器比较慢</span>

        <span class="keyword">try</span> {
            <span class="comment">// 查找MX记录</span>
            Lookup lookup = <span class="keyword">new</span> Lookup(hostName, Type.MX);
            lookup.run();
            <span class="keyword">if</span> (lookup.getResult() != Lookup.SUCCESSFUL) {
                log += <span class="string">"找不到MX记录\n"</span>;
                <span class="keyword">return</span> <span class="keyword">false</span>;
            } <span class="keyword">else</span> {
                result = lookup.getAnswers();
            }
<span class="comment">/*
             if(result.length &gt; 1) { // 优先级排序
                    List&lt;Record&gt; arrRecords = new ArrayList&lt;Record&gt;();
                    Collections.addAll(arrRecords, result);
                    Collections.sort(arrRecords, new Comparator&lt;Record&gt;() {

                        public int compare(Record o1, Record o2) {
                            return new CompareToBuilder().append(((MXRecord)o1).getPriority(), ((MXRecord)o2).getPriority()).toComparison();
                        }

                    });
                    host = ((MXRecord)arrRecords.get(0)).getTarget().toString();
                }
 * 
 */</span>
            <span class="comment">// 连接到邮箱服务器</span>

            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) {
                System.out.println(result[i].getAdditionalName().toString());
                System.out.println(((MXRecord)result[i]).getPriority());
            }
            <span class="keyword">int</span> count=<span class="number">0</span>;  
<span class="comment">//            String tempLog ="";</span>
            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) {
                log=<span class="string">""</span>;
                host = result[i].getAdditionalName().toString();
                <span class="keyword">try</span>{
                    client.connect(host);    <span class="comment">//连接到接收邮箱地址的邮箱服务器</span>
                }<span class="keyword">catch</span>(Exception e){        <span class="comment">//捕捉连接超时的抛出的异常</span>
                    count++;
                    <span class="keyword">if</span>(count&gt;=result.length){    <span class="comment">//如果由MX得到的result服务器都连接不上，则认定email无效</span>
                        log +=<span class="string">"Connect mail server timeout...\n"</span>;
                        <span class="keyword">return</span> <span class="keyword">false</span>;
                    }
                }

                <span class="keyword">if</span> (!SMTPReply.isPositiveCompletion(client.getReplyCode())) {    <span class="comment">//服务器通信不成功</span>
                    client.disconnect();
                    <span class="keyword">continue</span>;
                } <span class="keyword">else</span> {
                    log += <span class="string">"MX record about "</span> + hostName + <span class="string">" exists.\n"</span>;
                    log += <span class="string">"Connection succeeded to "</span> + host + <span class="string">"\n"</span>;
                    log += client.getReplyString();

                    <span class="comment">// HELO &lt;$SENDER_EMAIL_SERVER&gt;   //domain.com</span>
                    <span class="keyword">try</span>{
                        client.login(SENDER_EMAIL_SERVER);   <span class="comment">//这一步可能会出现空指针异常</span>
                    }<span class="keyword">catch</span>(Exception e){
                        <span class="keyword">return</span> <span class="keyword">false</span>;
                    }
                    log += <span class="string">"&gt;HELO "</span>+SENDER_EMAIL_SERVER+<span class="string">"\n"</span>;
                    log += <span class="string">"="</span> + client.getReplyString();

                    client.setSender(SENDER_EMAIL);
                    <span class="keyword">if</span>(client.getReplyCode()!=<span class="number">250</span>){        <span class="comment">//为解决hotmail有的MX可能出现=550 OU-001 (SNT004-MC1F43) Unfortunately, messages from 116.246.2.245 weren't sent.</span>
                        client.disconnect();
                        <span class="keyword">continue</span>;                            <span class="comment">//把client.login 和client.setSender放在循环体内，这样所有的如果某mx不行就换其他mx，但这样会对无效的邮箱进行所有mx遍历，耗时</span>
                    }
                    log += <span class="string">"&gt;MAIL FROM: &lt;"</span>+SENDER_EMAIL+<span class="string">"&gt;\n"</span>;
                    log += <span class="string">"="</span> + client.getReplyString();
                    <span class="comment">// RCPT TO: &lt;$email&gt;</span>
                    <span class="keyword">try</span>{
                        client.addRecipient(email);
                    }<span class="keyword">catch</span>(Exception e){
                        <span class="keyword">return</span> <span class="keyword">false</span>;
                    }
                    log += <span class="string">"&gt;RCPT TO: &lt;"</span> + email + <span class="string">"&gt;\n"</span>;
                    log += <span class="string">"="</span> + client.getReplyString();

                    <span class="comment">//最后从收件邮箱服务器返回true，说明服务器中能够找到此收件地址，邮箱有效</span>
                    <span class="keyword">if</span> (<span class="number">250</span> == client.getReplyCode()) {
                        <span class="keyword">return</span> <span class="keyword">true</span>;
                    }
                    client.disconnect();

                }
            }
<span class="comment">//            log+=tempLog;</span>
<span class="comment">//            log += "&gt;MAIL FROM: &lt;"+SENDER_EMAIL+"&gt;\n";</span>
<span class="comment">//            log += "=" + client.getReplyString();</span>
<span class="comment">//            </span>
<span class="comment">//            // RCPT TO: &lt;$email&gt;</span>
<span class="comment">//            try{</span>
<span class="comment">//                client.addRecipient(email);</span>
<span class="comment">//            }catch(Exception e){</span>
<span class="comment">//                return false;</span>
<span class="comment">//            }</span>
<span class="comment">//            log += "&gt;RCPT TO: &lt;" + email + "&gt;\n";</span>
<span class="comment">//            log += "=" + client.getReplyString();</span>
<span class="comment">//            </span>
<span class="comment">//            //最后从收件邮箱服务器返回true，说明服务器中能够找到此收件地址，邮箱有效</span>
<span class="comment">//            if (250 == client.getReplyCode()) {</span>
<span class="comment">//                return true;</span>
<span class="comment">//            }</span>
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        } <span class="keyword">finally</span> {
            <span class="keyword">try</span> {
                client.disconnect();
            } <span class="keyword">catch</span> (IOException e) {
            }
            <span class="comment">// print log</span>
            System.out.println(log);
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="comment">/**
     * This method is more accurate than checkEmailMethod(String email);
     * 
     * <span class="doctag">@param</span> email  The recipient's email address, it need to be validate if it is real exists or doesn't exists.
     * <span class="doctag">@return</span> True if email is real exists, false if not.
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkEmail</span><span class="params">(String email)</span></span>{
        <span class="keyword">if</span>(email.split(<span class="string">"@"</span>)[<span class="number">1</span>].equals(<span class="string">"qq.com"</span>)){
            <span class="keyword">if</span>( checkEmailMethod(email) &amp;&amp; checkEmailMethod(email) &amp;&amp; checkEmailMethod(email)){
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }<span class="keyword">else</span>{
                <span class="keyword">return</span> <span class="keyword">false</span>;
            }
        }
        <span class="keyword">return</span> checkEmailMethod(email);
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        CheckEmail ce = <span class="keyword">new</span> CheckEmail();
        <span class="keyword">if</span>(ce.checkEmail(<span class="string">"dfdegcex@qq.com"</span>)){
            System.out.println(<span class="string">"true"</span>);
        }<span class="keyword">else</span>{
            System.out.println(<span class="string">"false"</span>);
        }
    }

}
</code></pre>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其中还写了一点开发过程中的相关文档，生成了该功能相应的jar包。也生成了dll，写了供C#调用的使用方法。很简单。这里附上相关文件的链接：<a href="http://pan.baidu.com/s/1jHpdDjC" target="_blank" rel="external">http://pan.baidu.com/s/1jHpdDjC</a> &nbsp;&nbsp;密码：wio6</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java实现将选择题题库按照字母顺序重新排列]]></title>
      <url>http://www.bluestroy.com/2016/09/10/Java%E5%AE%9E%E7%8E%B0%E5%B0%86%E9%80%89%E6%8B%A9%E9%A2%98%E9%A2%98%E5%BA%93%E6%8C%89%E7%85%A7%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97/</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>记</strong>：若有开卷考试，且只能带纸质题库，而选择题题库又特别多，那么就可以用此方法将题库按照字母顺序排列，便于查找定位。  </p>
</blockquote>
<h3 id="巧用TreeMap"><a href="#巧用TreeMap" class="headerlink" title="巧用TreeMap"></a>巧用TreeMap</h3><p>Java中的Map是用来存储键值对的，其中HashMap没有固定的排列顺序，是通过hashcode对其内容进行快速查找。而TreeMap是由红黑树算法实现的，TreeMap在保存元素是按照key值的顺序排好序的。如果你需要得到一个有序的结果就应该使用TreeMap。TreeMap在不指定排序器时，默认按照key值进行升序排序。  </p>
<p>本方法需要先将题库拷贝到txt文本中（注意txt中\r\n表示一个换行符），取<strong>每道题去掉题号之后的第一行内容作为key，整个题目的内容作为value</strong>，则遍历完所有的题库并将其保存到TreeMap后，TreeMap中的题目就已经是按照A-Za-z的字母顺序排列了(key是字符串的话按照第一个字母的ASCII升序)，将其输出即可。  （A-65，a-97）</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>很简单，一看就懂。  </p>
<pre><code class="java"><span class="keyword">import</span> java.io.*;
<span class="keyword">import</span> java.util.HashMap;
<span class="keyword">import</span> java.util.Iterator;
<span class="keyword">import</span> java.util.TreeMap;
<span class="comment">/*
将选择题题库按照字母顺序重新排列
若有开卷考试，使用排序后的题库进行查找岂不是非常方便。
*/</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException</span>{
        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"tiku.txt"</span>));
        BufferedWriter out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"tiku_sort.txt"</span>));
        TreeMap&lt;String, String&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();
        String s, content = <span class="string">""</span>, key = <span class="string">""</span>;
        s = in.readLine();
        <span class="keyword">int</span> length;
        <span class="keyword">int</span> maxNumber = <span class="number">6</span>;      <span class="comment">//表示一共有多少到题，最大的题号</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxNumber; i++) {
            <span class="keyword">if</span> (s != <span class="keyword">null</span> &amp;&amp; s.startsWith(String.valueOf(i))) {
                key = <span class="string">""</span>;
                content = s + <span class="string">"\r\n"</span>;        <span class="comment">//在txt中\r\n表示一个换行符</span>
                <span class="keyword">if</span> (i &lt; <span class="number">10</span>) {
                    length = <span class="number">2</span>;                <span class="comment">//length表示除题号和.之外的内容开始的下标，用于后面key截取字符串的开始位置</span>
                }
                <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">100</span>) {
                    length = <span class="number">3</span>;
                }
                <span class="keyword">else</span> {
                    length = <span class="number">4</span>;
                }
                key = s.substring(length).replaceAll(<span class="string">" "</span>, <span class="string">""</span>).toLowerCase();    <span class="comment">//将每个题的第一行（去除题号后)作为key，用于排序</span>
                <span class="comment">//System.out.println(key+"-----------");</span>
            }
            <span class="comment">//将一道题的整个内容放入content</span>
            s = in.readLine();
            <span class="keyword">while</span> (s != <span class="keyword">null</span> &amp;&amp; !s.startsWith(String.valueOf((<span class="keyword">int</span>)(i+<span class="number">1</span>)))) {    <span class="comment">//因为题库都是按顺序的，所有这样写（i+1)</span>
                content += s + <span class="string">"\r\n"</span>;
                s = in.readLine();
            }
            <span class="comment">//TreeMap会自动按照键值进行排序建树</span>
            map.put(key, content);
        }

        <span class="comment">//整棵树的内容写到一个新的文件中。新的文件是按字母顺序排列（旧的文件按照题号排序）</span>
        Iterator&lt;String&gt; keys = map.keySet().iterator();
        <span class="keyword">while</span> (keys.hasNext()) {
            key = keys.next();
            content = map.get(key);
            out.write(content);
        }
        <span class="keyword">try</span>{
            in.close();
            out.close();
        }<span class="keyword">catch</span>(Exception e){}

    }
}
</code></pre>
<h3 id="样例输入与输出"><a href="#样例输入与输出" class="headerlink" title="样例输入与输出"></a>样例输入与输出</h3><p><b>1. 样例输入：  </b></p>
<blockquote>
<ol>
<li>d a respon…What.. this behavior?<br>A) Compare the conten…<br>B) Refer to the con…<br>C) Compare the contents of..<br>D) Refer to the ale..  </li>
<li>you decided to…lause? (Choose three.)<br>A. ALL<br>B. PFILE<br>C. BOTH<br>D. NONE  </li>
<li>efine aue… the event?<br>A) the alert.log file<br>B) the DBA_ALERTS view<br>C) the Database Control Home page<br>D) the Database Control performance page<br>E) the Database Control Maintenance page  </li>
</ol>
</blockquote>
<p><b>2. 样例输出： </b></p>
<blockquote>
<ol>
<li>d a respon…What.. this behavior?<br>A) Compare the conten…<br>B) Refer to the con…<br>C) Compare the contents of..<br>D) Refer to the ale..  <ol>
<li>efine aue… the event?<br>A) the alert.log file<br>B) the DBA_ALERTS view<br>C) the Database Control Home page<br>D) the Database Control performance page<br>E) the Database Control Maintenance page</li>
<li>you decided to…lause? (Choose three.)<br>A. ALL<br>B. PFILE<br>C. BOTH<br>D. NONE  </li>
</ol>
</li>
</ol>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[树莓派装系统+远程登录]]></title>
      <url>http://www.bluestroy.com/2016/09/10/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%A3%85%E7%B3%BB%E7%BB%9F-%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>——树莓派？好吃吗？<br>——Yes, It’s delicious, but for programer!  </p>
</blockquote>
<p>树莓派（Raspberry Pi)是只有信用卡卡片大小的微型电脑，系统基于Linux。吃货们要注意了，它是一台电脑，麻雀虽小，五脏可是俱全呢，树莓派是众多计算机发烧友和创客的玩具（价格二三百块钱），你可以用它做出很多令人惊喜而好玩的东西。  </p>
<p>废话不多说了，当你买来树莓派时，它还是一个裸机，需要你给它装系统。  </p>
<h2 id="树莓派装系统"><a href="#树莓派装系统" class="headerlink" title="树莓派装系统"></a>树莓派装系统</h2><ol>
<li>下载2015-05-05-raspbian-wheezy树莓派系统镜像文件</li>
<li>树莓派用SD卡来充当硬盘，用卡器将SD卡连接电脑，使用Win32DiskImager软件把系统镜像文件烧录到SD卡上</li>
<li>然后将SD卡插到树莓派上，把树莓派接通电源，树莓派即启动了。  </li>
</ol>
<p>很简单就将树莓派系统装好了。树莓派启动时，红灯亮、绿灯闪烁，当绿灯常亮时即启动成功。</p>
<blockquote>
<p>一开始因为不是很懂，进入系统后操作失误，后来又重装了系统。<br><strong>注意： </strong>重装系统时要先使用<strong>SDFormatterv4</strong>软件对SD卡进行格式化，如果直接<code>右键-&gt;格式化</code>的话很可能SD的容量没有完全释放掉，格式化后只显示很小的容量。  </p>
</blockquote>
<h2 id="树莓派远程登录"><a href="#树莓派远程登录" class="headerlink" title="树莓派远程登录"></a>树莓派远程登录</h2><p>如果有显示器和HDMI连接线，是可以直接将树莓派连接到显示其上使用的。这里讲一下没有的话要如何远程登录树莓派。</p>
<h3 id="1、获取树莓派的IP地址"><a href="#1、获取树莓派的IP地址" class="headerlink" title="1、获取树莓派的IP地址"></a>1、获取树莓派的IP地址</h3><p><strong>要远程登录树莓派首先要知道树莓派的IP地址：</strong><br>首先将网线插入树莓派，然后使用<strong>Advanced Ip Scanner</strong>软件进行Ip扫描，可以扫描出连接到当前局域网的所有设备。可以看到制造商为<strong>Raspberry Pi Foundation</strong>的设备就是树莓派，IP地址为10.199.157.36，听说树莓派的MAC 地址前几个数是固定的，也可通过Mac地址判断。如果连接的设备较多，可以根据自己的笔记本IP大概判断一下树莓派的IP，然后在软件的输入框中输入IP段范围，可以找的快一点。<br><img src="http://obmxnha1c.bkt.clouddn.com/20151012213447693.jpg" alt="Untitled Image">  </p>
<h3 id="2、使用Win7自带的mstsc远程登录"><a href="#2、使用Win7自带的mstsc远程登录" class="headerlink" title="2、使用Win7自带的mstsc远程登录"></a>2、使用Win7自带的mstsc远程登录</h3><p><code>开始 -&gt; 输入 mstsc</code>，弹出桌面远程连接，输入树莓派的ip地址后点击连接，就可以登录到树莓派系统了，中间要输入树莓派的账密，<code>默认账号：pi 密码：raspberry</code> 。下面是登录后的样子：<br><img src="http://obmxnha1c.bkt.clouddn.com/20151012214540119.jpg" alt="Untitled Image">  </p>
<h3 id="3、其他技巧"><a href="#3、其他技巧" class="headerlink" title="3、其他技巧"></a>3、其他技巧</h3><ul>
<li>我试了一下远程登录可以好几台电脑同时远程登录树莓派，互相之间操作的结果会同步，但其他人的操作动作不可见  </li>
<li>mstsc远程登录可以使用<code>ctrl+alt+Break</code>快捷键进行全盘切换，当键盘不灵时也可以切换一下就可以了</li>
<li>另外：也可以用<strong>ssh+putty</strong>进行远程登录  </li>
</ul>
<h2 id="树莓派无线网卡配置"><a href="#树莓派无线网卡配置" class="headerlink" title="树莓派无线网卡配置"></a>树莓派无线网卡配置</h2><p>如果是连接的路由器的wifi的话，这个百度经验上有，自行百度。<br><strong>注意</strong>：如果无线网卡配置信息过时或错误，同时插上无线网卡和网线远程登录可能会有问题，也可能上不了网，这个时候把无线网卡拔掉，直插网线就好。<br>【配置没成功，待定】</p>
]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>http://www.bluestroy.com/2016/08/08/Linux%20Makefile%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E2%80%94%E2%80%94makeNothing%20to%20be%20donw%20for%20'all'/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://www.bluestroy.com/2016/08/08/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
