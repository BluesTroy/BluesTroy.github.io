<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Java线程安全的容器类]]></title>
      <url>http://www.bluestroy.com/2016/09/20/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E7%B1%BB/</url>
      <content type="html"><![CDATA[<blockquote>
<p>转自<a href="http://blog.csdn.net/snail_ren/article/details/51969621" target="_blank" rel="external">Jeff的自留地：java线程安全的容器类</a>  </p>
</blockquote>
<p>Java编码中，我们经常需要用到容器来编程。在并发环境下，Java提供一些已有容器能够支持并发。Hashtable和Vector都是JKD早期版本的内容</p>
<h3 id="1-Map"><a href="#1-Map" class="headerlink" title="1. Map"></a>1. Map</h3><p><img src="http://obmxnha1c.bkt.clouddn.com/mapLei.jpg" alt="Untitled Image"></p>
<p>在Map类中，提供两种线程安全容器。</p>
<p><strong>java.util.Hashtable</strong>  </p>
<p>Hashtable和HashMap类似，都是散列表，存储键值对映射。主要区别在于Hashtable是线程安全的。当我们查看Hashtable源码的时候，可以看到Hashtable的方法都是通过synchronized来进行方法层次的同步，以达到线程安全的作用。</p>
<p><strong>java.util.concurrent.ConcurrentHashMap</strong><br>ConcurrentHashMap是性能更好的散列表。在兼顾线程安全的同时，相对于Hashtable，在效率上有很大的提高。我们可以猜想，Hashtable的线程安全实现是对方法进行synchronized，很明显可以通过其他并发方式，如ReentrantLock进行优化。而ConcurrentHashMap正是采用了ReentrantLock。运用锁分离技术，即在代码块上加锁，而不是方法上加。同时ConcurrentHashMap的一个特色是允许多个修改并发操作。这就有意思了，我们知道一般写都是互斥的，为什么这个还能多个同时写呢？那是因为ConcurrentHashMap采用了内部使用段机制，将ConcurrentHashMap分成了很多小段。只要不在一个小段上写就可以并发写。</p>
<h3 id="2-Collection"><a href="#2-Collection" class="headerlink" title="2. Collection"></a>2. Collection</h3><p><img src="http://obmxnha1c.bkt.clouddn.com/collectionLei.jpg" alt="Untitled Image"></p>
<p>Collection部分主要是运用的CopyOnWrite机制，即写时复制机制。从字面上就能理解什么意思，就是当我们往一个容器里添加元素的时候，先对这个容器进行一次复制，对副本进行写操作。写操作结束后，将原容器的引用指向新副本容器，就完成了写的刷新。从它的实现原理，我们可以看出这种机制是存在缺点的。</p>
<p>1.内存占用：毫无疑问，每次写时需要首先复制一遍原容器，假如复制了很多，或者本身原容器就比较大，那么肯定会占用很多内存。可以采用压缩容器中的元素来防止内存消耗过大。</p>
<p>2.数据一致性问题：当我们在副本中进行写操组时，只能在最终结束后使数据同步，不能实时同步</p>
<p>可以看到，这种机制适用于读操作多，写操作少的应用场景。</p>
<p><strong>java.util.concurrent.CopyOnWriteArrayList</strong></p>
<p>Collection类的线程安全容器主要都是利用的ReentrantLock实现的线程安全，CopyOnWriteArrayList也不例外。在并发写的时候，需要获取lock。读的时候不需要进行lock</p>
<p><strong>java.util.concurrent.CopyOnWriteArraySet</strong></p>
<p>CopyOnWriteArraySet的实现就是基于CopyOnWriteArrayList实现的，采用的装饰器进行实现。二者的区别和List和Set的区别一样。</p>
<p><strong>Vector</strong></p>
<p>一般我们都不用Vector了，不过它确实也是线程安全的。相对于其他容器，能够提供随机访问功能。</p>
<h3 id="3-StringBuffer和StringBuilder"><a href="#3-StringBuffer和StringBuilder" class="headerlink" title="3. StringBuffer和StringBuilder"></a>3. StringBuffer和StringBuilder</h3><p>我们知道，String在进行+操作的时候，原生的String会重新新建一个String对象来完成字符串拼接，明显这种操作多了的话会加重服务器负担。因此我们需要的时候就会用StringBuffer和StringBuilder。这二者有什么区别呢？</p>
<p><strong>StringBuffer</strong>是线程安全的，StringBuilder不是。从StringBuffer的源码可以看到，它采用的是对方法进行synchronized实现的同步。但是加了同步机制，肯定会对性能有一定影响。  </p>
<blockquote>
<p>高并发情况下，对数据安全有需求，则用StringBuffer，否则用StringBuilder</p>
</blockquote>
<p><br></p>
<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><strong>java.util.Hashtable</strong>：synchronized实现</li>
<li><strong>*java.util.concurrent.ConcurrentHashMap</strong>: ReentrantLock实现</li>
<li><strong>ava.util.concurrent.CopyOnWriteArrayList</strong>: ReentrantLock实现</li>
<li><strong>java.util.concurrent.CopyOnWriteArraySet</strong>: ReentrantLock实现</li>
<li><strong>Vector</strong>: ReentrantLock实现</li>
<li><strong>StringBuffer</strong>： synchronized实现</li>
</ol>
<blockquote>
<p>前1.2.属Map，3.4.5.属Collection。<br>注：新程序中不应该使用过时的Vector、Hashtable和Stack等。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java并发的点点滴滴]]></title>
      <url>http://www.bluestroy.com/2016/09/20/Java%E5%B9%B6%E5%8F%91%E7%9A%84%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4/</url>
      <content type="html"><![CDATA[<p><strong>争用条件：</strong> 当多个线程同时共享访问同一数据（内存区域）时，每个线程都尝试操作该数据，从而导致数据被破坏（corrupter），这种现象称为争用条件（条件争用）。  </p>
<p><strong>线程的交互：</strong> 互斥与同步</p>
<p><strong>互斥：</strong> 关键数据在同一时间只能被一个线程访问。<br><strong>同步：</strong> 一种通信机制。<br><strong>object方法：</strong> wait()/notify()/notifyAll();</p>
<p><strong>可见性：</strong> 一个线程对共享变量值的修改，能够及时地被其他线程看到。<br><strong>共享变量：</strong> 如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。<br><strong>Java内存模型（JMM)：</strong><br>所有变量都存储在主内存中，每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）。 </p>
<div align="center"><br><img src="http://obmxnha1c.bkt.clouddn.com/tempClipboardImage.png" width="400" height="220"><br></div>

<blockquote>
<p>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从内存中读写。<br>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量的值的传递需要通过主内存来完成。  </p>
</blockquote>
<p><br></p>
<p>可见性语言层面的实现方式：  </p>
<ol>
<li>synchronized  </li>
<li>volatile  </li>
</ol>
<p>synchronized可保证原子性，但volatile不能保证原子性。  </p>
<h3 id="待学习"><a href="#待学习" class="headerlink" title="待学习"></a>待学习</h3><p>//reentrantLock<br>//final也可以保证内存可见性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">lock.lock();</div><div class="line">	<span class="keyword">try</span>&#123;</div><div class="line">    	number++;</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">    	lock.unlock();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常见数据结构]]></title>
      <url>http://www.bluestroy.com/2016/09/19/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<blockquote>
<p>四种基本数据结构：集合、线性结构、树形结构、图状街头。</p>
<p>注：新程序中不应该使用过时的Vector、Hashtable和Stack等。</p>
</blockquote>
<h4 id="Stack栈"><a href="#Stack栈" class="headerlink" title="Stack栈"></a>Stack栈</h4><p>先进后出，使用LinkedList实现的。  </p>
<ul>
<li>push():压入栈    </li>
<li>pop(): 移除并返回栈顶元素  </li>
<li>peek(): 提供栈顶元素但不移除  </li>
<li>empty(): 栈是否为空  </li>
</ul>
<h4 id="Queue队列"><a href="#Queue队列" class="headerlink" title="Queue队列"></a>Queue队列</h4><p>先进先出，队列在并发编程中特别重要，因为它们可以安全地将对象从一个任务传输到另一个任务。  </p>
<ul>
<li>offer(): 添加一个元素到队尾并返回true，若队列满则返回false。</li>
<li>peek(): 返回队列头部元素，若队列空则返回null。</li>
<li>element(): 返回队列头部元素，若队列空则抛出NoSuchElementException异常。</li>
<li>poll(): 移除并返回队头元素，若队列空则返回null。</li>
<li>remove(): 移除并返队头元素，若队列空则抛出NoSuchElementException异常。  </li>
</ul>
<h4 id="用两个栈实现一个队列"><a href="#用两个栈实现一个队列" class="headerlink" title="用两个栈实现一个队列"></a>用两个栈实现一个队列</h4><blockquote>
<ol>
<li>插入操作在stack1中进行，删除操作在stack2中进行  </li>
<li>如果stack2为空，则将stack1中的所有元素转移到stack2中  </li>
<li>出栈时如果两个栈都为空，则抛出NoSuchElementException异常并处理。</li>
</ol>
</blockquote>
<h4 id="使用两个队列实现一个栈"><a href="#使用两个队列实现一个栈" class="headerlink" title="使用两个队列实现一个栈"></a>使用两个队列实现一个栈</h4><blockquote>
<ol>
<li>有两个队列q1和q2，先往q1内插入a，b，c，这做的都是栈的push操作。</li>
<li>现在要做pop操作，即要得到c，这时可以将q1中的a,b两个元素全部dequeue并存入q2中，这时q2中元素为a，b，对q1再做一次dequeue操作即可得到c。</li>
<li>如果继续做push操作，比如插入d，f，则把d，f插入到q2中，</li>
<li>此时若要做pop操作，则做步骤2</li>
<li>以此类推，就实现了用两个队列来实现一个栈的目的。</li>
</ol>
<p>新push进来的元素总是插入到非空队列中，空队列保存一次pop之后的元素。那么原来的空队列变成非空，原来的非空队列变成了空，总是这样循环。<br>push和pop  时间复杂度O(n)。</p>
</blockquote>
<h4 id="优先队列PriorityQueue"><a href="#优先队列PriorityQueue" class="headerlink" title="优先队列PriorityQueue"></a>优先队列PriorityQueue</h4><p>优先队列调用offer方法来插入一个对象时，这个对象会在队列中被排序。默认的排序将使用对象在队列中的自然顺序，可提供自己的Comparator来修该这个顺序。PriorityQueue可确保调用peek、poll、remove方法时，获取的元素是队列中优先级最高的元素。PriorityQueue与Integer、String、character内置类型一起工作易如反掌。（若是String,空格也算值，且优先级高于字母）</p>
<blockquote>
<p>PriorityQueue本质上是堆排序里面的小根堆。</p>
</blockquote>
<p>PriorityQueue例子。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"></div><div class="line">*在做算法题的时候可以考虑使用PriorityQueue*</div><div class="line"></div><div class="line">#### Arrays工具类用法总结</div><div class="line">``` java</div><div class="line">    int[] a = &#123;-3,3,5,11,54,63,74&#125;;</div><div class="line">    int[] b = &#123;-3,3,5,11,54,63,74&#125;;</div><div class="line">    Integer[] c = &#123;15,6,788,2,3,56,9&#125;;</div><div class="line">    Arrays.toString(a); //打印数组</div><div class="line">    int y =Arrays.binarySearch(a,11);   //二分查找，返回找到的下标，找不到返回负数</div><div class="line">    int[] xa=Arrays.copyOf(a,3);    //复制数组的前三个元素为另一个数组</div><div class="line">    int[] xb = Arrays.copyOfRange(a,0,2);   //复制数组下标&gt;=0,&lt;2的部分</div><div class="line">    boolean z =Arrays.equals(a,b);  //判断两个数组内容是否相同</div><div class="line">    Arrays.fill(a,7);   //数组元素全部填充为7</div><div class="line">    Arrays.fill(a,2,4,0);   //数组下标&gt;=2,&lt;4的元素填充为0</div><div class="line">    Arrays.sort(c,2,6); //对数组下标&gt;=2,&lt;6的部分升序排序</div><div class="line">    Arrays.sort(c);     //对数组进行升序排序</div><div class="line">    Arrays.sort(c,Collections.&lt;Integer&gt;reverseOrder());//对数组进行降序排序</div><div class="line">    Arrays.sort(c,new Comparator&lt;Integer&gt;()&#123;//自定义降序排序排序</div><div class="line">        @Override</div><div class="line">        public int compare(Integer a, Integer b)&#123;</div><div class="line">            return b.compareTo(a);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    Arrays.sort(c);     //对数组进行升序排序</div><div class="line">    Arrays.sort(c, 0, 4, new Comparator&lt;Integer&gt;() &#123; //自定义数组下标&gt;=0,&lt;4的部分降序</div><div class="line">        @Override</div><div class="line">        public int compare(Integer o1, Integer o2) &#123;</div><div class="line">            return o2.compareTo(o1);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<h4 id="Collections工具类用法总结"><a href="#Collections工具类用法总结" class="headerlink" title="Collections工具类用法总结"></a>Collections工具类用法总结</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">	List list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    Collections.addAll(list,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>);<span class="comment">//将后面的元素都添加到list中</span></div><div class="line">    Collections.reverseOrder();<span class="comment">//返回一个Comparator&lt;T&gt;倒序排序的接口对象</span></div><div class="line">    println(list);</div><div class="line">    Collections.reverse(list);  <span class="comment">//将列表逆序排序</span></div><div class="line">    Collections.sort(list); <span class="comment">//将列表升序排序</span></div><div class="line">    println(list);</div><div class="line">    Collections.sort(list,Collections.reverseOrder());  <span class="comment">//将列表降序排序</span></div><div class="line"></div><div class="line">    List list2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    Collections.addAll(list2,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">45</span>);</div><div class="line">    <span class="keyword">int</span> index = Collections.binarySearch(list2,<span class="number">12</span>); <span class="comment">//二分查找，返回下标，无则返回负数</span></div><div class="line">    println(list);</div><div class="line">    println(index);</div><div class="line"></div><div class="line">    Object max = Collections.max(list); <span class="comment">//返回最大值</span></div><div class="line">    Object min = Collections.min(list); <span class="comment">//返回最小值</span></div><div class="line">    println(<span class="string">"max:"</span>+max);</div><div class="line">    println(<span class="string">"min:"</span>+min);</div><div class="line"></div><div class="line">    List list3 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;()&#123;&#123;add(<span class="number">2</span>);add(<span class="number">3</span>);add(<span class="number">5</span>);add(<span class="number">7</span>);add(<span class="number">6</span>);add(<span class="number">8</span>);&#125;&#125;;<span class="comment">//初始化</span></div><div class="line"><span class="comment">//        Collections.synchronizedList(list);</span></div><div class="line">    <span class="comment">//查找是否有某子列表，有则返回第一个子列表下标，无则返回-1</span></div><div class="line">    <span class="keyword">int</span> sindex = Collections.indexOfSubList(list3,Arrays.asList(<span class="number">2</span>,<span class="number">3</span>));</div><div class="line">    <span class="comment">//查找是否有某子列表，有则返回最后一个子列表下标，无则返回-1</span></div><div class="line">    <span class="keyword">int</span> lindex = Collections.lastIndexOfSubList(list3,Arrays.asList(<span class="number">2</span>,<span class="number">3</span>));</div><div class="line">    println(<span class="string">"first index:"</span>+sindex);</div><div class="line">    println(<span class="string">"last index:"</span>+lindex);</div><div class="line"></div><div class="line">    Collections.rotate(list3,<span class="number">2</span>);<span class="comment">//集合中元素后移2个位置，益处的循环到前面</span></div><div class="line">    println(list3);</div><div class="line">    Collections.shuffle(list3);<span class="comment">//对集合进行洗牌，即打乱顺序</span></div><div class="line">    println(list3);</div><div class="line">    Collections.swap(list3,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//交换集合中第0个和第一个元素</span></div><div class="line">    println(list3);</div><div class="line"></div><div class="line">    <span class="comment">//list本身不是同步的，此法得到线程安全的list</span></div><div class="line">    <span class="comment">//【注意】即直接使用它提供的单个函数，可以同步。但若多个函数想同步，必须自己做同步。</span></div><div class="line">    List safeList = Collections.synchronizedList(list3);</div><div class="line"></div><div class="line">    <span class="comment">//三个final类型的类变量，在某些情况下，我们经常需要返回一个空的集合对象，</span></div><div class="line">    <span class="comment">//比如在数据查询时，并不需要发挥一个NULL或是异常，那么就可以返回一个空的集合对象。</span></div><div class="line">    List emptyList = Collections.EMPTY_LIST;    <span class="comment">//创建一个空列表</span></div><div class="line">    emptyList = Collections.emptyList();    <span class="comment">//同上，下面类推</span></div><div class="line">    Map emptyMap = Collections.EMPTY_MAP;  <span class="comment">//创建一个空map</span></div><div class="line">    Set emptySet = Collections.EMPTY_SET;  <span class="comment">//创建一个空集合</span></div></pre></td></tr></table></figure>
<h4 id="Java线程安全的容器类"><a href="#Java线程安全的容器类" class="headerlink" title="Java线程安全的容器类"></a>Java线程安全的容器类</h4><ol>
<li><strong>java.util.Hashtable</strong>：synchronized实现</li>
<li><strong>*java.util.concurrent.ConcurrentHashMap</strong>: ReentrantLock实现</li>
<li><strong>ava.util.concurrent.CopyOnWriteArrayList</strong>: ReentrantLock实现</li>
<li><strong>java.util.concurrent.CopyOnWriteArraySet</strong>: ReentrantLock实现</li>
<li><strong>Vector</strong>: ReentrantLock实现</li>
<li><strong>StringBuffer</strong>： synchronized实现</li>
</ol>
<blockquote>
<p>前1.2.属Map，3.4.5.属Collection。</p>
</blockquote>
<h4 id="容器本身也有很多有用的方法，待总结。"><a href="#容器本身也有很多有用的方法，待总结。" class="headerlink" title="容器本身也有很多有用的方法，待总结。"></a>容器本身也有很多有用的方法，待总结。</h4>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于Git，你不需要记住更多]]></title>
      <url>http://www.bluestroy.com/2016/09/17/%E5%85%B3%E4%BA%8EGit%EF%BC%8C%E4%BD%A0%E4%B8%8D%E9%9C%80%E8%A6%81%E8%AE%B0%E4%BD%8F%E6%9B%B4%E5%A4%9A/</url>
      <content type="html"><![CDATA[<h4 id="关联本地仓库和远程仓库"><a href="#关联本地仓库和远程仓库" class="headerlink" title="关联本地仓库和远程仓库"></a>关联本地仓库和远程仓库</h4><p>首先，需要本地创建一个文件<code>test</code>，将其初始化为git<br>仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git init</div></pre></td></tr></table></figure></p>
<p>然后，在github服务器端也创建一个同名仓库<code>test</code>，执行以下命令关联远程仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote add origin git@github.com:BluesTroy/test.git</div></pre></td></tr></table></figure></p>
<p>接着，就可以将本地库的内容推送到远程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push -u origin master</div></pre></td></tr></table></figure></p>
<p>第一次推送到<code>master</code>分支时，<code>-u</code>参数会把本地<code>master</code>分支和远程<code>master</code>分支关联，之后就可以直接使用简化命令<code>git push</code>和<code>git pull</code>了。</p>
<h4 id="拉取远程特定分支"><a href="#拉取远程特定分支" class="headerlink" title="拉取远程特定分支"></a>拉取远程特定分支</h4><p>远程分支和本地分支需要区分，所以，在从服务器上拉取特定分支的时候，需要指定本地分支名字。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout --track origin/develop</div></pre></td></tr></table></figure></p>
<p>注意该命令由于带有–track参数，所以要求git1.6.4以上！这样git会自动切换到develop分支。</p>
<h4 id="为git命令设置别名"><a href="#为git命令设置别名" class="headerlink" title="为git命令设置别名"></a>为git命令设置别名</h4><p>将以下内容追加到<code>C:\Users\Troy\.gitconfig</code>文件，就可以用简化命令，如<code>git st</code>来代替<code>git status</code>。  </p>
<blockquote>
<p>[alias]<br>  co = checkout<br>  ci = commit<br>  br = branch<br>  st = status<br>  unstage = reset HEAD<br>  last = log -1<br>  lg = log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit</p>
</blockquote>
<h4 id="git修复冲突"><a href="#git修复冲突" class="headerlink" title="git修复冲突"></a>git修复冲突</h4><h5 id="修复merge冲突"><a href="#修复merge冲突" class="headerlink" title="修复merge冲突"></a>修复merge冲突</h5><p>如<code>develop</code>分支与<code>dev</code>分支合并：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout develop</div><div class="line">$ git merge dev</div></pre></td></tr></table></figure></p>
<p>因为合并时有冲突，会出现分支(develop|MERGING)情况，会列出CONFLICT冲突的文件有哪些。<br><strong>解决：</strong><br>依次进入冲突文件，会出现冲突部分之前的内容和最新的内容，其中<br>==== HEAD<br>\======<br>=====dev<br>之间相关的内容要处理掉，需要保留最新的有用的内容，删掉旧的内容。<br>处理完成后执行以下命令即可修复冲突：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add -A</div><div class="line">$ git commit -m <span class="string">'fix conflict'</span></div></pre></td></tr></table></figure></p>
<h5 id="修复rebase冲突"><a href="#修复rebase冲突" class="headerlink" title="修复rebase冲突"></a>修复rebase冲突</h5><p>使用以下命令可能会出现<code>rebase</code>冲突：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull --rebase</div></pre></td></tr></table></figure></p>
<p>冲突出现和解决与<code>merge</code>冲突类似，解决完后执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add -A</div><div class="line">git rebase --continue</div></pre></td></tr></table></figure></p>
<h4 id="ssh生成公钥和私钥"><a href="#ssh生成公钥和私钥" class="headerlink" title="ssh生成公钥和私钥"></a>ssh生成公钥和私钥</h4><p>git需要ssh访问的公钥<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen</div></pre></td></tr></table></figure></p>
<h4 id="gitignore使用方法"><a href="#gitignore使用方法" class="headerlink" title=".gitignore使用方法"></a>.gitignore使用方法</h4><p>在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 此为注释 – 将被 Git 忽略  </div><div class="line">*.a       # 忽略所有 .a 结尾的文件  </div><div class="line">!lib.a    # 但 lib.a 除外  </div><div class="line">/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO </div><div class="line">build/    # 忽略 build/ 目录下的所有文件  </div><div class="line">doc/*.txt # 会忽略 doc/notes.txt 但不包括   doc/server/arch.txt</div></pre></td></tr></table></figure></p>
<p><strong>如果某文件已添加到<code>.gitignore</code>，但不起作用，下面三条命令可解决：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git rm -r --cached .</div><div class="line">$ git add .</div><div class="line">$ git commit -m <span class="string">'update .gitignore'</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交</p>
</blockquote>
<h4 id="git多人协作常用命令"><a href="#git多人协作常用命令" class="headerlink" title="git多人协作常用命令"></a>git多人协作常用命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># 从服务器上clone</div><div class="line">git clone ssh://git@xxx.xxx.xxx.xxx/opt/fashion/fashion.git  </div><div class="line"></div><div class="line">git branch dev	#本地建立新分支dev</div><div class="line">git checkout dev	#切换到dev分支</div><div class="line">#这样就可在dev分支上进行操作了,万一代码写错,还可以还原到原先的分支  </div><div class="line"></div><div class="line">git branch -d dev	#删除dev分支</div><div class="line">git branch	#查看当前分支HEAD</div><div class="line"></div><div class="line">#一但代码修改以后,保存自己写的代码到本地</div><div class="line">git status</div><div class="line">git add -A</div><div class="line">git commit -m “这段修改的代码你做了什么,写在这里面,方便别人看到”</div><div class="line"></div><div class="line">#接下来将自己的代码更新到网上</div><div class="line">git checkout develop</div><div class="line">git pull --rebase	#拉取服务器最新代码</div><div class="line">git merge dev	#将dev分支合并到develop分支</div><div class="line">git push	#提交自己的最新代码到服务器</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[各种排序算法总结]]></title>
      <url>http://www.bluestroy.com/2016/09/15/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><img src="http://obmxnha1c.bkt.clouddn.com/266279_1442481223258_BB3663E2B94AB7FD90C31D24E4C6E7EB.jpg" alt="Untitled Image"><br><em>快排的辅助存储应该是log(n)</em><br><em>稳定的含义：  两个相同元素的相对位置不变。</em></p>
<hr>
<h3 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1 快速排序"></a>1 快速排序</h3><h5 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h5><blockquote>
<p>①以第一个关键字 K 1 为控制字，将 [K 1 ,K 2 ,…,K n ] 分成两个子区，使左区所有关键字小于等于 K 1 ，右区所有关键字大于等于 K 1 ，最后控制字居两个子区中间的适当位置。在子区内数据尚处于无序状态。<br>②把左区作为一个整体，用①的步骤进行处理，右区进行相同的处理。（即递归）<br>③重复第①、②步，直到左区处理完毕。`  </p>
</blockquote>
<h5 id="1-2-Java实现"><a href="#1-2-Java实现" class="headerlink" title="1.2 Java实现"></a>1.2 Java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 快速排序</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> a     待排序的数组</div><div class="line"> * <span class="doctag">@param</span> left  待排序区间的开始下标</div><div class="line"> * <span class="doctag">@param</span> right 待排序区间的结束下标</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> i = left;</div><div class="line">    <span class="keyword">int</span> j = right;</div><div class="line">    <span class="keyword">int</span> key = a[i];    <span class="comment">//以第一个数为关键字</span></div><div class="line">    <span class="comment">//经过一趟后，关键字在中间的某处，左边的都比其小，右边的都比其大</span></div><div class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">        <span class="comment">//先从j开始由右往左，遇见比关键字小的则将此数放到左边i的位置，然后i++</span></div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= key) &#123;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</div><div class="line">            a[i] = a[j];</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//然后再从i开始由左往右，遇见比关键字大的数则将此数放到j的位置，然后j--</span></div><div class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= key) &#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</div><div class="line">            a[j] = a[i];</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    a[i] = key;</div><div class="line">    <span class="comment">//然后对左右区间分别执行快排算法</span></div><div class="line">    quickSort(a, left, i - <span class="number">1</span>);</div><div class="line">    quickSort(a, i + <span class="number">1</span>, right);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-3-算法分析"><a href="#1-3-算法分析" class="headerlink" title="1.3 算法分析"></a>1.3 算法分析</h5><p>每次分成两组，分logn次，每趟比较n次。<br><strong>时间复杂度</strong>： O(nlogn)<br><strong>最坏情况</strong>：O(n^2)<br><strong>空间复杂度</strong>：O(+logn)<br><strong>不稳定</strong></p>
<blockquote>
<p>始序列有序时，快速排序效率最低<br>快排每一趟就是O(n)，在一般情况下递归深度是log(n)，所以总的复杂度是O(nlogn)。在有序的情况下，递归深度变成了n，所以总复杂度会退化到O(n*n)</p>
</blockquote>
<p><strong>针对快速排序的最坏情况进行的改进方法</strong> </p>
<blockquote>
<p>改进方法主要是对控制字pivot的选取进行改进，默认的是选取区间的第一个节点。<br>改进方法1. 随机选取区间里面的的一个数作为控制字。<br>改进方法2. 对区间的left,middle,last三数取中作为关键字，避开了随机数产生器的开销又带了了一定程度的随机性。<br><em>改进方法还有其他很多种。</em>  </p>
</blockquote>
<p><strong>快速排序的优化</strong></p>
<ol>
<li>待排序序列的长度分割到一定大小后，使用插入排序。（比如right-left+1&lt;10）。<strong>原因：</strong> 对于很小和部分有序的数组，快排不如插排好。</li>
<li>优化尾部递归、使用并行或多线程处理子序列等其他。</li>
</ol>
<h3 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2 冒泡排序"></a>2 冒泡排序</h3><p>按从小到大排序：</p>
<h5 id="2-1-思路"><a href="#2-1-思路" class="headerlink" title="2.1 思路"></a>2.1 思路</h5><blockquote>
<ol>
<li>按从前往后的顺序多次扫描，每次扫描向后比较相邻元素，若后面比前面小，则交换它们</li>
<li>第一趟扫描完后，最后一个元素应该是最大的数</li>
<li>同理扫描前n-1个数，第二次扫描第二大元素则变为倒数第二个位置</li>
<li>以此类推</li>
</ol>
</blockquote>
<h5 id="2-2-Java实现"><a href="#2-2-Java实现" class="headerlink" title="2.2 Java实现"></a>2.2 Java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 冒泡排序</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> a 待排序的数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">    <span class="comment">//n个数，进行n-1次扫描</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="comment">//每次扫描都比较前i个数，每两个相邻的数，将小的放前面</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</div><div class="line">                temp = a[j];</div><div class="line">                a[j] = a[j + <span class="number">1</span>];</div><div class="line">                a[j + <span class="number">1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-3-算法分析"><a href="#2-3-算法分析" class="headerlink" title="2.3 算法分析"></a>2.3 算法分析</h5><p>感觉冒泡排序交换次数太多，用的比较少<br><strong>时间复杂度</strong>： O(n^2)<br><strong>最坏情况</strong>：O(n^2)<br><strong>最好</strong>：O(n)<br><strong>空间复杂度</strong>：O(1)<br><strong>稳定</strong></p>
<h3 id="3-直接选择排序"><a href="#3-直接选择排序" class="headerlink" title="3 直接选择排序"></a>3 直接选择排序</h3><h5 id="3-1-思路"><a href="#3-1-思路" class="headerlink" title="3.1 思路"></a>3.1 思路</h5><blockquote>
<p>每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法</p>
<h5 id="3-2-Java实现"><a href="#3-2-Java实现" class="headerlink" title="3.2 Java实现"></a>3.2 Java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 直接选择排序</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> a 待排序的数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, temp = <span class="number">0</span>;</div><div class="line">    <span class="comment">//进行n次扫描</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</div><div class="line">        min = i;</div><div class="line">        <span class="comment">//每一次扫描取出待排序中最小的元素</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (a[min] &gt; a[j]) &#123;</div><div class="line">                min = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//将该最小的元素放到待排序序列的第一个位置</span></div><div class="line">        <span class="keyword">if</span> (min != i) &#123;</div><div class="line">            temp = a[min];</div><div class="line">            a[min] = a[i];</div><div class="line">            a[i] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-3-算法分析"><a href="#3-3-算法分析" class="headerlink" title="3.3 算法分析"></a>3.3 算法分析</h5><p><strong>时间复杂度</strong>： O(n^2)<br><strong>最坏情况</strong>：O(n^2)<br><strong>空间复杂度</strong>：O(1)<br><strong>不稳定</strong></p>
<h3 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4 堆排序"></a>4 堆排序</h3><p>以大根堆为例：</p>
<h5 id="4-1-思路"><a href="#4-1-思路" class="headerlink" title="4.1 思路"></a>4.1 思路</h5><blockquote>
<ol>
<li>将一个无序数列建成一个初始堆</li>
<li>输出堆顶元素并调整剩余元素成为一个新堆</li>
<li>重复1和2，则最终按顺序输出的数列即为排好序的数列</li>
</ol>
</blockquote>
<h6 id="4-2-构建初始堆"><a href="#4-2-构建初始堆" class="headerlink" title="4.2 构建初始堆"></a>4.2 构建初始堆</h6><ol>
<li>首先数列构造一个完全二叉树。  </li>
<li>n为下标，从0开始。则最后一个非叶节点下标x是[n/2]向下取整，故从x处从后往前进行调整。  </li>
<li>每次比较父节点、左孩子、右孩子，将最小的孩子与父节点交换。</li>
<li>每次交换后需对被交换的孩子节点进行调整  </li>
</ol>
<h5 id="4-3-Java实现"><a href="#4-3-Java实现" class="headerlink" title="4.3 Java实现"></a>4.3 Java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/**</span></div><div class="line">     * 调整堆，使满足堆的定义。此例为大根堆</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> a          待排序的数组</div><div class="line">     * <span class="doctag">@param</span> startIndex 待调整堆的开始下标</div><div class="line">     * <span class="doctag">@param</span> endIndex   待调整堆的结束下标</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</div><div class="line">        <span class="comment">//start和end分别为【初始下标】和【结束下标】</span></div><div class="line">        <span class="keyword">int</span> temp;</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        <span class="keyword">for</span> (; <span class="number">2</span> * startIndex + <span class="number">1</span> &lt;= endIndex; startIndex = i) &#123;</div><div class="line">            i = <span class="number">2</span> * startIndex + <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (i &lt; endIndex &amp;&amp; a[i] &lt; a[i + <span class="number">1</span>]) &#123;</div><div class="line">                i++;  <span class="comment">//i为较大孩子节点的下标</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (a[startIndex] &lt; a[i]) &#123; <span class="comment">//左右孩子中获胜者与父亲比较</span></div><div class="line">                <span class="comment">//将孩子结点上位，则以孩子结点的位置进行下一轮的筛选</span></div><div class="line">                temp = a[startIndex];</div><div class="line">                a[startIndex] = a[i];</div><div class="line">                a[i] = temp;</div><div class="line"><span class="comment">//                start = i;</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//因为整棵树是从下往上调整数，所以，若父节点不需要调整，说明该节点子树已满足堆性质，跳出循环</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 堆排序</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> a 待排序的数组</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;   <span class="comment">//从最后一个非叶节点开始，建立初始堆</span></div><div class="line">            heapAdjust(a, i, a.length - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//进行排序</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</div><div class="line">            <span class="comment">//将待排序区最后一个元素和第一个元素进行交换</span></div><div class="line">            <span class="keyword">int</span> temp = a[i];</div><div class="line">            a[i] = a[<span class="number">0</span>];</div><div class="line">            a[<span class="number">0</span>] = temp;</div><div class="line">            <span class="comment">//将剩下的无序元素调整为大顶堆</span></div><div class="line">            heapAdjust(a, <span class="number">0</span>, i - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 算法分析</h5><p><strong>时间复杂度</strong>： O(nlogn)<br><strong>最坏情况</strong>：O(nlogn)<br><strong>空间复杂度</strong>：O(1)<br><strong>不稳定</strong></p>
<blockquote>
<p><strong>堆排序方法对记录数较少的文件并不值得提倡，但对n较大的文件还是很有效的</strong>。因为其运行时间主要耗费在建初始堆和调整建新堆时进行的反复“筛选”上。<br>堆排序在最坏的情况下，其时间复杂度也为O(nlogn)。相对于快速排序来说，这是堆排序的最大优点。此外，堆排序仅需一个记录大小的供交换用的辅助存储空间。</p>
</blockquote>
<h3 id="5-直接插入排序"><a href="#5-直接插入排序" class="headerlink" title="5 直接插入排序"></a>5 直接插入排序</h3><h5 id="5-1-思路"><a href="#5-1-思路" class="headerlink" title="5.1 思路"></a>5.1 思路</h5><ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到下一位置中</li>
<li>重复步骤2~5<h5 id="5-2-Java实现"><a href="#5-2-Java实现" class="headerlink" title="5.2 Java实现"></a>5.2 Java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 直接插入排序</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> a 待排序的数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="comment">//遍历数组</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</div><div class="line">        temp = a[i]; <span class="comment">//将待排序的第一个元素放到监视哨中，作为要插入的数</span></div><div class="line">        j = i - <span class="number">1</span>;  <span class="comment">//从后往前开始查找的位置j</span></div><div class="line">        <span class="keyword">while</span> (j &gt; -<span class="number">1</span> &amp;&amp; temp &lt; a[j]) &#123;</div><div class="line">            a[j + <span class="number">1</span>] = a[j];    <span class="comment">//将大于该数的右移</span></div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        a[j + <span class="number">1</span>] = temp;    <span class="comment">//最终找到插入位置为j+1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="5-3-算法分析"><a href="#5-3-算法分析" class="headerlink" title="5.3 算法分析"></a>5.3 算法分析</h5><p>感觉直接插入排序的移动次数太多，效率也不高<br><strong>时间复杂度</strong>： O(n^2)<br><strong>最坏情况</strong>：O(n^2)<br><strong>最好</strong>： O(n)<br><strong>空间复杂度</strong>：O(1)<br><strong>稳定</strong></p>
<h3 id="6-希尔（shell）排序"><a href="#6-希尔（shell）排序" class="headerlink" title="6 希尔（shell）排序"></a>6 希尔（shell）排序</h3><h5 id="6-1-思路"><a href="#6-1-思路" class="headerlink" title="6.1 思路"></a>6.1 思路</h5><blockquote>
<ol>
<li>先取一个正整数d1&lt;n，把所有序号相隔d1的数组元素放一组，组内进行<strong>直接插入排序</strong></li>
<li>然后取d2&lt;d1，重复上述分组和排序操作</li>
<li>直至di=1，即所有记录放进一个组中排序为止<h5 id="6-2-Java实现"><a href="#6-2-Java实现" class="headerlink" title="6.2 Java实现"></a>6.2 Java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 希尔排序，步长依次为 n/2,n/4,.....</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> a 待排序的数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> d = a.length / <span class="number">2</span>; <span class="comment">//初始步长</span></div><div class="line">    <span class="keyword">while</span> (d &gt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; d; x++) &#123;   <span class="comment">//一共有x组</span></div><div class="line">            <span class="comment">//对每一组进行直接插入排序</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = x + d; i &lt; a.length; i += d) &#123;</div><div class="line">                <span class="keyword">int</span> temp = a[i];</div><div class="line">                <span class="keyword">int</span> j = i - d;</div><div class="line">                <span class="keyword">while</span> (j &gt; x - <span class="number">1</span> &amp;&amp; temp &lt; a[j]) &#123;</div><div class="line">                    a[j + d] = a[j];</div><div class="line">                    j -= d;</div><div class="line">                &#125;</div><div class="line">                a[j + d] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        d = d / <span class="number">2</span>;  <span class="comment">//缩短步长</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h5 id="6-3-算法分析"><a href="#6-3-算法分析" class="headerlink" title="6.3 算法分析"></a>6.3 算法分析</h5><p><strong>时间复杂度</strong>： O(n^1.3)<br><strong>最坏情况</strong>：O(n^2)<br><strong>最好</strong>： O(n)<br><strong>空间复杂度</strong>：O(1)<br><strong>不稳定</strong></p>
<h3 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7 归并排序"></a>7 归并排序</h3><h5 id="7-1-思路"><a href="#7-1-思路" class="headerlink" title="7.1 思路"></a>7.1 思路</h5><blockquote>
<ol>
<li>将序列每相邻两个数字进行归并操作（merge)，形成floor(n/2)个序列，排序后每个序列包含两个元素  </li>
<li>将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素  </li>
<li>重复步骤2，直到所有元素排序完毕<br><strong>&lt; 超优美的递归 &gt;</strong></li>
</ol>
<p>如:<br>设有数列{6，202，100，301，38，8，1}<br>初始状态：6，202，100，301，38，8，1<br>第一次归并后：{6，202}，{100，301}，{8，38}，{1}，比较次数：3；<br>第二次归并后：{6，100，202，301}，{1，8，38}，比较次数：4；<br>第三次归并后：{1，6，8，38，100，202，301}，比较次数：4；<br>总的比较次数为：3+4+4=11，<br>逆序数为14。</p>
<h5 id="7-2-Java实现"><a href="#7-2-Java实现" class="headerlink" title="7.2 Java实现"></a>7.2 Java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 二路归并</div><div class="line"> * <span class="doctag">@param</span> a 要归并的数组</div><div class="line"> * <span class="doctag">@param</span> startIndex 要归并数组的起始下标-即第一个子序列的开始下标</div><div class="line"> * <span class="doctag">@param</span> midIndex 要归并数组的中点下标-即第二个子序列的开始下标</div><div class="line"> * <span class="doctag">@param</span> endIndex 要归并数组的终点下标</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> startIndex, <span class="keyword">int</span> midIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = startIndex; <span class="comment">//第一个序列的下标</span></div><div class="line">    <span class="keyword">int</span> j = midIndex +<span class="number">1</span>;<span class="comment">//第二个序列的下标</span></div><div class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;   <span class="comment">// k是临时数组的下标</span></div><div class="line">    <span class="keyword">int</span> [] array = <span class="keyword">new</span> <span class="keyword">int</span>[endIndex-startIndex+<span class="number">1</span>]; <span class="comment">//临时合并数组</span></div><div class="line">    <span class="comment">//每次取出两个序列中的小者，将其放到合并数组中（两个子序列已时排好序的）</span></div><div class="line">    <span class="keyword">while</span>(i&lt;=midIndex &amp;&amp; j&lt;=endIndex)&#123;</div><div class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])&#123;</div><div class="line">            array[k] = a[i];</div><div class="line">            i++;k++;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            array[k]=a[j];</div><div class="line">            j++;k++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//若第一个序列没扫描完，则将其全部复制到合并数组</span></div><div class="line">    <span class="keyword">while</span> (i&lt;=midIndex)&#123;</div><div class="line">        array[k] = a[i];</div><div class="line">        i++;k++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//若第二个序列没扫描完，则将其全部复制到合并数组</span></div><div class="line">    <span class="keyword">while</span> (j&lt;=endIndex)&#123;</div><div class="line">        array[k] = a[j];</div><div class="line">        j++;k++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//将合并数组复制到原序列中</span></div><div class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>,i=startIndex;i&lt;=endIndex;i++,k++)&#123;</div><div class="line">        a[i] = array[k];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 归并排序，内部使用递归，太优美了</div><div class="line"> * <span class="doctag">@param</span> a 要排序的数组</div><div class="line"> * <span class="doctag">@param</span> startIndex 要排序的起始下标</div><div class="line"> * <span class="doctag">@param</span> endIndex 要排序的终点下标</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> midIndex;</div><div class="line">    <span class="keyword">if</span>(startIndex &lt; endIndex)&#123;</div><div class="line">        midIndex = (startIndex+endIndex)/<span class="number">2</span>;</div><div class="line">        mergeSort(a, startIndex, midIndex);</div><div class="line">        mergeSort(a, midIndex+<span class="number">1</span>, endIndex);</div><div class="line">        merge(a,startIndex,midIndex,endIndex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<h5 id="7-3-算法分析"><a href="#7-3-算法分析" class="headerlink" title="7.3 算法分析"></a>7.3 算法分析</h5><p><strong>时间复杂度</strong>： O(nlogn)<br><strong>最坏情况</strong>：O(nlogn)<br><strong>最好</strong>： O(nlogn)<br><strong>空间复杂度</strong>：O(n)<br><strong>稳定</strong></p>
<h2 id="gt-归并排序需要一个数组保存结果，所以辅助存储为O-n-。是空间复杂度最高的排序。"><a href="#gt-归并排序需要一个数组保存结果，所以辅助存储为O-n-。是空间复杂度最高的排序。" class="headerlink" title="&gt; 归并排序需要一个数组保存结果，所以辅助存储为O(n)。是空间复杂度最高的排序。"></a>&gt; 归并排序需要一个数组保存结果，所以辅助存储为O(n)。是空间复杂度最高的排序。</h2><p><strong><em>以上所有，都应深深地印在脑子里。  </em></strong></p>
<p><img src="http://obmxnha1c.bkt.clouddn.com/21457204_1326898064RUxx.jpg" alt="Untitled Image"><br><strong>*图上有错</strong>：归并排序需要一个数组保存结果，所以辅助存储为O(n)*  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于数据结构的小知识]]></title>
      <url>http://www.bluestroy.com/2016/09/15/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h4 id="二叉树的深度和高度"><a href="#二叉树的深度和高度" class="headerlink" title="二叉树的深度和高度"></a>二叉树的深度和高度</h4><blockquote>
<p>树的深度是从根节点开始（其深度为1）自顶向下逐层累加的，而高度是从叶节点开始（其高度为1）自底向上逐层累加的。  </p>
</blockquote>
<p>二叉树的深度h即为二叉树的层数，二叉树最多含有节点数为 2^h-1。<br>第i层节点数： 2^(i-1)  </p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><blockquote>
<p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。  </p>
</blockquote>
<h4 id="完全二叉树："><a href="#完全二叉树：" class="headerlink" title="完全二叉树："></a>完全二叉树：</h4><blockquote>
<p>只有最下面两层节点度能够小于2，并且最下面一层的节点都集中在该层最左边的若干位置的二叉树。</p>
</blockquote>
<p>若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是<strong>完全二叉树</strong>。  </p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><blockquote>
<p>除叶子节点外的所有节点均有两个子节点，即节点数达到最大值。 2^h-1   </p>
</blockquote>
<p><strong>叶子数：</strong> 2^h<br><strong>第k层节点数：</strong> 2^(k-1)<br><strong>总结点数：</strong> 2^k-1</p>
<h4 id="二叉排序树（二叉查找树、二叉搜索树）"><a href="#二叉排序树（二叉查找树、二叉搜索树）" class="headerlink" title="二叉排序树（二叉查找树、二叉搜索树）"></a>二叉排序树（二叉查找树、二叉搜索树）</h4><blockquote>
<p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<br>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）左、右子树也分别为二叉排序树；<br>（4）没有键值相等的结点。</p>
<div align="center"><br><img src="http://obmxnha1c.bkt.clouddn.com/94cad1c8a786c9179df9bed6c93d70cf3ac75763.jpg" width="300" height="180" align="center"><br></div>

</blockquote>
<h4 id="哈夫曼树（最优二叉树）"><a href="#哈夫曼树（最优二叉树）" class="headerlink" title="哈夫曼树（最优二叉树）"></a>哈夫曼树（最优二叉树）</h4><blockquote>
<p>带权路径长度最短的二叉树。  </p>
</blockquote>
<p><strong>节点的带权路径长度：</strong> 从根结点到该结点之间的路径长度与该结点的权的乘积  </p>
<p><strong>树的带权路径长度：</strong> 所有<strong><em>叶子结点</em></strong>的带权路径长度之和，记为WPL</p>
<h6 id="哈夫曼编码步骤"><a href="#哈夫曼编码步骤" class="headerlink" title="哈夫曼编码步骤"></a>哈夫曼编码步骤</h6><blockquote>
<p>一、对给定的n个权值{W1,W2,W3,…,Wi,…,Wn}构成n棵二叉树的初始集合F= {T1,T2,T3,…,Ti,…,Tn}，其中每棵二叉树Ti中只有一个权值为Wi的根结点，它的左右子树均为空。（为方便在计算机上实现算 法，一般还要求以Ti的权值Wi的升序排列。）<br>二、在F中选取两棵根结点权值最小的树作为新构造的二叉树的左右子树，新二叉树的根结点的权值为其左右子树的根结点的权值之和。<br>三、从F中删除这两棵树，并把这棵新的二叉树同样以升序排列加入到集合F中。<br>四、重复二和三两步，直到集合F中只有一棵二叉树为止。</p>
</blockquote>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>Ki(i从0开始）。 则Ki的左孩子为K(2i+1)，右孩子K(2i+2)。父节点为Parent(i)=K[(i-1)/2]  </p>
<p><strong>小根堆：</strong> K[i]&lt;=K[2i+1] &amp;&amp; K[i]&lt;=K[2i+2]<br><strong>大根堆：</strong> K[i]&gt;=K[2i+1] &amp;&amp; K[i]&gt;=K[2i+2]  </p>
<p>空间复杂度：O(1)，建堆复杂度O(n)，调整堆的复杂度O(nlogn)</p>
<h4 id="各种排序算法复杂度"><a href="#各种排序算法复杂度" class="headerlink" title="各种排序算法复杂度"></a>各种排序算法复杂度</h4><p><img src="http://blog.chinaunix.net/attachment/201201/18/21457204_1326898064RUxx.jpg" alt="各种排序算法复杂度"></p>
<h4 id="死锁的4个必要条件"><a href="#死锁的4个必要条件" class="headerlink" title="死锁的4个必要条件"></a>死锁的4个必要条件</h4><p>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不可抢占（不剥夺）条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。  </p>
<h4 id="标准的SQL解析顺序"><a href="#标准的SQL解析顺序" class="headerlink" title="标准的SQL解析顺序"></a>标准的SQL解析顺序</h4><p>(1).FROM 子句, 组装来自不同数据源的数据<br>(2).WHERE 子句, 基于指定的条件对记录进行筛选<br>(3).GROUP BY 子句, 将数据划分为多个分组<br>(4).使用聚合函数进行计算<br>(5).使用 HAVING 子句筛选分组<br>(6).计算Select所有的表达式<br>(7).使用 ORDER BY 对结果集进行排序  </p>
<h4 id="简述abstract-类和interface的区别"><a href="#简述abstract-类和interface的区别" class="headerlink" title="简述abstract 类和interface的区别"></a>简述abstract 类和interface的区别</h4><p>同： abstract类 和接口都可以有abstract方法<br>不同：  </p>
<ol>
<li><p>接口中只可以有常量，不能有变量；而abstract类中既可以有常量也可以有变量  </p>
</li>
<li><p>abstract类也可以有非abstract方法，接口不可以。  </p>
</li>
<li>实现接口是一定要实现接口里定义的所有方法，而实现抽象类可以有选择的重写需要用到的方法。  </li>
<li>接口是公开的，里面不能有私有的方法和变量。而首次昂类是可以有私有方法和私有变量的。  </li>
<li>Java抽象类可以提供某些方法的部分实现，而Java接口不可以（就是interface中只能定义方法，而不能有方法的实现，而在abstract class中则可以既有方法的具体实现，又有没有具体实现的抽象方法）  </li>
<li>子类只能单继承抽象类；而子类能够同时实现多个接口</li>
</ol>
<h4 id="java中对象什么时候被垃圾回收"><a href="#java中对象什么时候被垃圾回收" class="headerlink" title="java中对象什么时候被垃圾回收"></a>java中对象什么时候被垃圾回收</h4><p>当没有任何对象的引用指向对象时，在一个不可预期的时间内对象才会被回收  </p>
<p>当对象的引用为空，当对象堆当前使用这个对象的应用程序不可触及的时候，这个对象就可以被回收了。</p>
<blockquote>
<p>一个对象，可以有一个或多个引用变量指向它。当一个对象不再有任何一个引用变量指向它时，这个对象就被应用抛弃了。或者说，这个对象可以被垃圾回收机制回收了。这就是说，当不存在对某对象的任何引用时，就意味着，应用告诉JVM：我不要这个对象，你可以回收了。  </p>
<p>JVM的垃圾回收机制对堆空间做实时检测。当发现某对象的引用计数为0时，就将该对象列入待回收列表中。但是，并不是马上予以销毁</p>
</blockquote>
<h4 id="计算1！-2！-……-n-（最简单的单循环方法）"><a href="#计算1！-2！-……-n-（最简单的单循环方法）" class="headerlink" title="计算1！+2！+……+n!（最简单的单循环方法）"></a>计算1！+2！+……+n!（最简单的单循环方法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> n;</div><div class="line">		<span class="keyword">long</span> sum =<span class="number">0</span>;</div><div class="line">		<span class="keyword">long</span> temp =<span class="number">1</span>;</div><div class="line">		Scanner cin = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">		n = cin.nextInt();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">			temp*=i;	</div><div class="line">			sum+=temp;</div><div class="line">		&#125;</div><div class="line">		System.out.println(sum);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> s_id,c_id,score</div><div class="line"><span class="keyword">from</span> grade</div><div class="line"><span class="keyword">where</span> score&gt;<span class="number">80</span>;</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> s_name,c_id,score</div><div class="line"><span class="keyword">from</span> grade,student</div><div class="line"><span class="keyword">where</span> score&gt;<span class="number">80</span> <span class="keyword">and</span> grade.s_id = student.s_id;</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> s_name,c_name,score</div><div class="line"><span class="keyword">from</span> student,course,grade</div><div class="line"><span class="keyword">where</span> score <span class="keyword">is</span> <span class="literal">NULL</span> <span class="keyword">and</span> student.s_id = grade.s_id <span class="keyword">and</span> course.c_id = grade.c_id;</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> s_id</div><div class="line"><span class="keyword">from</span> grade </div><div class="line"><span class="keyword">where</span> <span class="keyword">min</span>(score) &gt;<span class="number">80</span></div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> s_id;</div></pre></td></tr></table></figure>
<p>列出学生及格和不及格的科目数，栏位包括学生号、及格科目数、不及格科目数：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> a.s_id, <span class="keyword">count</span>(a), <span class="keyword">count</span>(b)</div><div class="line"><span class="keyword">from</span> grade <span class="keyword">as</span> a,</div><div class="line">	(<span class="keyword">select</span> s_id <span class="keyword">from</span> grade <span class="keyword">where</span> score &lt; <span class="number">60</span>) <span class="keyword">as</span> b </div><div class="line"><span class="keyword">where</span> a.score&gt;<span class="number">60</span> <span class="keyword">and</span> a.s_id = b.s_id </div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> s_id;</div></pre></td></tr></table></figure></p>
<h4 id="Java单例模式"><a href="#Java单例模式" class="headerlink" title="Java单例模式"></a>Java单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 懒汉模式，线程不安全</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance =<span class="keyword">null</span>;</div><div class="line">   	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    	<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">        	instance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//懒汉模式 线程安全</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance =<span class="keyword">null</span>;</div><div class="line">   	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    	<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">        	instance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//懒汉模式 线程安全优化</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance =<span class="keyword">null</span>;</div><div class="line">   	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    	<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">        	<span class="keyword">synchronized</span>(Singleton.class)&#123;</div><div class="line">            	<span class="keyword">if</span>(instance ==<span class="keyword">null</span>)&#123;</div><div class="line">                	instance = <span class="keyword">new</span> Singleton();</div><div class="line">            	&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 饿汉模式，无线程安全问题</span></div><div class="line"> * 缺点是类一加载就实例化，提前占用系统资源。</div><div class="line"> * 但实际可能并没有用到</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">   	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="在3亿个数中找出不重复的整数，假设电脑内存之后2G"><a href="#在3亿个数中找出不重复的整数，假设电脑内存之后2G" class="headerlink" title="在3亿个数中找出不重复的整数，假设电脑内存之后2G"></a>在3亿个数中找出不重复的整数，假设电脑内存之后2G</h4><p>待回答。</p>
<h4 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h4><blockquote>
<ol>
<li>https协议需要到ca申请证书，一般免费证书很少，需要交费。 </li>
<li>http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议  </li>
<li>http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。  </li>
<li>http的连接很简单,是无状态的  </li>
<li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全  </li>
</ol>
</blockquote>
<h4 id="数据库的并发控制"><a href="#数据库的并发控制" class="headerlink" title="数据库的并发控制"></a>数据库的并发控制</h4><p><strong>数据库的并发操作通常会带来3个问题：</strong></p>
<ol>
<li>丢失更新问题：两个事务的操作交错执行，引起数据不正确</li>
<li>读脏数据问题：另一个事务读了一个事务未提交的值</li>
<li>不可重复读问题：一个事务两次读A操作间隔中，另一事务改变了A，两次同一数据却读出了不同的值  </li>
</ol>
<p><em>脏数据：未提交的随后被撤销（Rollback）的数据。</em></p>
<blockquote>
<p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个被更新后的数据。  </p>
</blockquote>
<p><em>这写问题都可通过并发控制子系统解决。</em></p>
<p>基本锁有X锁，S锁和U锁。</p>
<h4 id="系统平均无故障时间——可靠性。X个9的含义"><a href="#系统平均无故障时间——可靠性。X个9的含义" class="headerlink" title="系统平均无故障时间——可靠性。X个9的含义"></a>系统平均无故障时间——可靠性。X个9的含义</h4><p><em>参考</em> <a href="http://blog.csdn.net/alonesword/article/details/21555745" target="_blank" rel="external">什么是“5个9”(99.999%)的可靠性？</a></p>
<p><br><br><br></p>
<p><em>你也许会不经意的发现，这篇文章对解决17招行笔试题很有帮助，那还不赶快打个赏！！</em>  </p>
<p><br><br><br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux常用命令]]></title>
      <url>http://www.bluestroy.com/2016/09/12/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="一、crontab简介"><a href="#一、crontab简介" class="headerlink" title="一、crontab简介"></a>一、crontab简介</h3><p>crontab命令常见于Unix和类Unix系统中，用于设置周期性被执行的命令。该命令从标准输入设备读取指令，并将其存放在<code>crontab</code>文件中，以供之后读取和执行。 </p>
<h5 id="1、crontab调度文件规则"><a href="#1、crontab调度文件规则" class="headerlink" title="1、crontab调度文件规则"></a>1、crontab调度文件规则</h5><p>命令格式：<code>* * * * * command</code><br><strong>*</strong> 依次表示<strong>分钟、小时、日、月、星期</strong>  </p>
<ul>
<li>分钟——每小时的第几分钟执行，范围0~59  </li>
<li>小时——每日的第几个小时执行，范围0~23</li>
<li>日——每月的第几天执行，范围1~31  </li>
<li>月——每年你的第几月执行 ，范围1~12  </li>
<li>星期——每周的第几天执行，范围0~6  </li>
</ul>
<h5 id="2、crontab命令的例子"><a href="#2、crontab命令的例子" class="headerlink" title="2、crontab命令的例子"></a>2、crontab命令的例子</h5><p><strong>*</strong> 表示该范围内任意时候，如每分钟执行一次：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* * * * * date &gt; /home/mydate</div></pre></td></tr></table></figure>
<p>每天晚上11点到早上8点之间每两个小时，即早上八点 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 23-7/2 * * * date</div></pre></td></tr></table></figure></p>
<p>每两个小时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 */2 * * * date</div></pre></td></tr></table></figure></p>
<p>每个月的4号和每周的周一到周三的早上11点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 11 4 * mon-wed date</div></pre></td></tr></table></figure></p>
<p>每天18 : 00至23 : 00之间每隔30分钟重启apache：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0,30 18-23 * * * /usr/local/etc/rc.d/lighttpd restart</div></pre></td></tr></table></figure></p>
<h5 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">crontab -r <span class="comment">#停止（即删除）所有任务（慎用）</span></div><div class="line">crontab <span class="_">-l</span> <span class="comment">#列出所有任务</span></div></pre></td></tr></table></figure>
<h3 id="二、文件中-atime-ctime-mtime简介"><a href="#二、文件中-atime-ctime-mtime简介" class="headerlink" title="二、文件中 -atime, -ctime, -mtime简介"></a>二、文件中 -atime, -ctime, -mtime简介</h3><ul>
<li>atime(Access time)，访问时间，如读取文件</li>
<li>ctime(Change time), 状态时间，如修改权限、属性、所有者</li>
<li>mtime(Modified time), 修改时间，文件内容修改的时间<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">find . -mtime +3 <span class="comment">#3天以前修改的文件(&gt;3)  </span></div><div class="line">find . -mtime -3 <span class="comment">#3天之内修改的文件(&lt;3)</span></div><div class="line">find . -mtime 1 <span class="comment">#距离当前时间24~24*2小时内修改的文件(即当前时间的“昨天内”）</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="三、-amin-cmin-mmin简介"><a href="#三、-amin-cmin-mmin简介" class="headerlink" title="三、-amin, -cmin, -mmin简介"></a>三、-amin, -cmin, -mmin简介</h3><p>与atime，ctime，mtime用法相同，只不过time表示天，min表示分钟</p>
<h3 id="四、history命令"><a href="#四、history命令" class="headerlink" title="四、history命令"></a>四、history命令</h3><p>显示最近使用的5个命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">history</span> 5</div></pre></td></tr></table></figure></p>
<p>执行历史编号为5的命令那个：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ !5</div></pre></td></tr></table></figure></p>
<p>执行最后一次以ls结尾的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ !ls</div></pre></td></tr></table></figure></p>
<h3 id="五、为bash脚本设置别名"><a href="#五、为bash脚本设置别名" class="headerlink" title="五、为bash脚本设置别名"></a>五、为bash脚本设置别名</h3><p>修改<code>~/.bashrc</code>文件，该文件是登录用户的启动文件，能用作用户的全局设置。<br>假定在/opt/fashion/目录下编写了某一键部署的bash脚本命令文件<code>deploy.sh</code>，则在<code>~./bashrc</code>文件中添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias go=&apos;/opt/fashion/deploy.sh&apos;</div></pre></td></tr></table></figure></p>
<p>那么在命令行中直接执行<code>go</code>命令即可执行<code>deploy.sh</code>文件中的命令。  </p>
<p>注意：编辑完后执行<code>source ./bashrc</code>命令使其生效，若不能生效则重新登录生效。  </p>
<h3 id="六、usermod将用户添加到用户组"><a href="#六、usermod将用户添加到用户组" class="headerlink" title="六、usermod将用户添加到用户组"></a>六、usermod将用户添加到用户组</h3><p>千万不能直接用 <code>usermode -G groupName userName</code>，这样做会使你离开其他用户组，仅仅作为用户组groupName的成员。<br>应该加上<code>-a</code>选项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ usermod <span class="_">-a</span> -G sudo userName</div></pre></td></tr></table></figure></p>
<p>-a代表append，也就是将用户添加到用户组sudo中，而不必离开其他用户组。  </p>
<h3 id="七、head-和tail"><a href="#七、head-和tail" class="headerlink" title="七、head 和tail"></a>七、head 和tail</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">head -n 20 /etc/man.config <span class="comment">#列出前20行</span></div><div class="line">head -n -100 /etc/man.config <span class="comment">#列出除最后100行的之前的所有行  </span></div><div class="line">tail -n 20 /etc/ <span class="comment">#列出最后20行  </span></div><div class="line">tail -n +100 /etc/man.config <span class="comment">#列出除前100行的之后的所有行  </span></div><div class="line">head -n 20 /etc/man.config | tail -n 10 <span class="comment">#显示第11到20行</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux中mysql数据库定时备份]]></title>
      <url>http://www.bluestroy.com/2016/09/12/Linux%E4%B8%ADmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD/</url>
      <content type="html"><![CDATA[<h4 id="Linux中，为mysql数据库备份，并删除一个月以前的备份数据"><a href="#Linux中，为mysql数据库备份，并删除一个月以前的备份数据" class="headerlink" title="Linux中，为mysql数据库备份，并删除一个月以前的备份数据"></a>Linux中，为mysql数据库备份，并删除一个月以前的备份数据</h4><p>mysql_backup.sh备份脚本命令如下：</p>
<pre><code class="bash"><span class="meta">#! /bin/bash</span>
<span class="comment"># 按照时间戳来命名备份数据，便于管理</span>
DATE=`date+%Y-%m-%d-%H:%M:%S`  
mysqldump -u root -p123456 mysqldbName &gt; /mysql_backup/backdata/mysqldbName_<span class="variable">${DATE}</span>.bak  
<span class="comment"># 删除30天以前的备份数据</span>
find /mysql_backup/backdata/ -atime +30 | xargs rm
</code></pre>
<p>其中root是mysql用户，123456是用户密码，msyqldbName是数据库名字，该备份命令会将mysqldbName数据库的数据全部备份到/mysql<em>backup/backdata目录下，并以mysqldbName\</em>加上时间戳的形式命名。 </p>
<h4 id="crontab定时备份任务"><a href="#crontab定时备份任务" class="headerlink" title="crontab定时备份任务"></a>crontab定时备份任务</h4><p>将mysql_backup.sh脚本文件的执行加入到crontab定时任务中，编辑crontab定时任务:</p>
<pre><code class="bash">$ crontab <span class="_">-e</span>
</code></pre>
<p>将一下内容追加到crontab文件中：</p>
<pre><code class="bash">0 12 * * * /mysql_backup/mysql_backup.sh
0 0 * * * /mysql_backup/mysql_backup.sh
</code></pre>
<p>第一行内容表示每天中午12点执行mysql_backup.sh中的备份命令，第二行表示每天凌晨执行备份命令。你可以在任意时候执行备份命令，只需要学习一下crontab的 <em> </em> <em> </em> * 分别代表什么意思就可以。  </p>
<h4 id="mysql数据库恢复备份数据"><a href="#mysql数据库恢复备份数据" class="headerlink" title="mysql数据库恢复备份数据"></a>mysql数据库恢复备份数据</h4><pre><code class="bash">$ mysql -u root -p123456 mysqldbName &lt; /mysql_backup/backdata/mysqldbName_xxxxxx.bak
</code></pre>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java实现通过smtp服务器验证邮箱的真实有效性]]></title>
      <url>http://www.bluestroy.com/2016/09/10/Java%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%BF%87smtp%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AA%8C%E8%AF%81%E9%82%AE%E7%AE%B1%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%9C%89%E6%95%88%E6%80%A7/</url>
      <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>设置一个已有邮箱地址，通过向邮箱服务器发送一个请求，去与目标邮箱地址通信，根据邮箱服务器的返回结果来判断目标邮箱地址是否是真实有效的邮箱。  </p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>该程序要用到commons-net-3.3.jar、dnsjava-2.1.7.jar包</li>
<li>大部分的国内常见邮箱都能准确验证</li>
<li>验证频率和数量多的话容易被封掉ip</li>
<li>使用了”no-reply@domain.com”作为发送邮箱，不要用自己使用的邮箱作为程序的发送邮箱，验证频率和数量多的话邮箱地址容易被封  </li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="java"><span class="keyword">package</span> com.tieniu;
<span class="keyword">import</span> java.io.IOException;

<span class="keyword">import</span> org.apache.commons.net.smtp.SMTPClient;
<span class="keyword">import</span> org.apache.commons.net.smtp.SMTPReply;
<span class="keyword">import</span> org.xbill.DNS.Lookup;
<span class="keyword">import</span> org.xbill.DNS.MXRecord;
<span class="keyword">import</span> org.xbill.DNS.Record;
<span class="keyword">import</span> org.xbill.DNS.Type;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckEmail</span> </span>{

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SENDER_EMAIL = <span class="string">"no-reply@domain.com"</span>;<span class="comment">//"no-reply@domain.com";</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SENDER_EMAIL_SERVER = SENDER_EMAIL.split(<span class="string">"@"</span>)[<span class="number">1</span>];<span class="comment">//"domain.com";</span>


    <span class="comment">/**
     * 
     * <span class="doctag">@param</span> email  The recipient's email address, it need to be validate if it is real exists or doesn't exists.
     * <span class="doctag">@return</span> True if email is real exists, false if not.
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkEmailMethod</span><span class="params">(String email)</span> </span>{
        <span class="keyword">if</span> (!email.matches(<span class="string">"[\\w\\.\\-]+@([\\w\\-]+\\.)+[\\w\\-]+"</span>)) {
            System.err.println(<span class="string">"Format error"</span>);
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }

        String log = <span class="string">""</span>;
        String host = <span class="string">""</span>;
        String hostName = email.split(<span class="string">"@"</span>)[<span class="number">1</span>];
        Record[] result = <span class="keyword">null</span>;
        SMTPClient client = <span class="keyword">new</span> SMTPClient();
        client.setConnectTimeout(<span class="number">8000</span>);  <span class="comment">//设置连接超时时间,有些服务器比较慢</span>

        <span class="keyword">try</span> {
            <span class="comment">// 查找MX记录</span>
            Lookup lookup = <span class="keyword">new</span> Lookup(hostName, Type.MX);
            lookup.run();
            <span class="keyword">if</span> (lookup.getResult() != Lookup.SUCCESSFUL) {
                log += <span class="string">"找不到MX记录\n"</span>;
                <span class="keyword">return</span> <span class="keyword">false</span>;
            } <span class="keyword">else</span> {
                result = lookup.getAnswers();
            }
<span class="comment">/*
             if(result.length &gt; 1) { // 优先级排序
                    List&lt;Record&gt; arrRecords = new ArrayList&lt;Record&gt;();
                    Collections.addAll(arrRecords, result);
                    Collections.sort(arrRecords, new Comparator&lt;Record&gt;() {

                        public int compare(Record o1, Record o2) {
                            return new CompareToBuilder().append(((MXRecord)o1).getPriority(), ((MXRecord)o2).getPriority()).toComparison();
                        }

                    });
                    host = ((MXRecord)arrRecords.get(0)).getTarget().toString();
                }
 * 
 */</span>
            <span class="comment">// 连接到邮箱服务器</span>

            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) {
                System.out.println(result[i].getAdditionalName().toString());
                System.out.println(((MXRecord)result[i]).getPriority());
            }
            <span class="keyword">int</span> count=<span class="number">0</span>;  
<span class="comment">//            String tempLog ="";</span>
            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) {
                log=<span class="string">""</span>;
                host = result[i].getAdditionalName().toString();
                <span class="keyword">try</span>{
                    client.connect(host);    <span class="comment">//连接到接收邮箱地址的邮箱服务器</span>
                }<span class="keyword">catch</span>(Exception e){        <span class="comment">//捕捉连接超时的抛出的异常</span>
                    count++;
                    <span class="keyword">if</span>(count&gt;=result.length){    <span class="comment">//如果由MX得到的result服务器都连接不上，则认定email无效</span>
                        log +=<span class="string">"Connect mail server timeout...\n"</span>;
                        <span class="keyword">return</span> <span class="keyword">false</span>;
                    }
                }

                <span class="keyword">if</span> (!SMTPReply.isPositiveCompletion(client.getReplyCode())) {    <span class="comment">//服务器通信不成功</span>
                    client.disconnect();
                    <span class="keyword">continue</span>;
                } <span class="keyword">else</span> {
                    log += <span class="string">"MX record about "</span> + hostName + <span class="string">" exists.\n"</span>;
                    log += <span class="string">"Connection succeeded to "</span> + host + <span class="string">"\n"</span>;
                    log += client.getReplyString();

                    <span class="comment">// HELO &lt;$SENDER_EMAIL_SERVER&gt;   //domain.com</span>
                    <span class="keyword">try</span>{
                        client.login(SENDER_EMAIL_SERVER);   <span class="comment">//这一步可能会出现空指针异常</span>
                    }<span class="keyword">catch</span>(Exception e){
                        <span class="keyword">return</span> <span class="keyword">false</span>;
                    }
                    log += <span class="string">"&gt;HELO "</span>+SENDER_EMAIL_SERVER+<span class="string">"\n"</span>;
                    log += <span class="string">"="</span> + client.getReplyString();

                    client.setSender(SENDER_EMAIL);
                    <span class="keyword">if</span>(client.getReplyCode()!=<span class="number">250</span>){        <span class="comment">//为解决hotmail有的MX可能出现=550 OU-001 (SNT004-MC1F43) Unfortunately, messages from 116.246.2.245 weren't sent.</span>
                        client.disconnect();
                        <span class="keyword">continue</span>;                            <span class="comment">//把client.login 和client.setSender放在循环体内，这样所有的如果某mx不行就换其他mx，但这样会对无效的邮箱进行所有mx遍历，耗时</span>
                    }
                    log += <span class="string">"&gt;MAIL FROM: &lt;"</span>+SENDER_EMAIL+<span class="string">"&gt;\n"</span>;
                    log += <span class="string">"="</span> + client.getReplyString();
                    <span class="comment">// RCPT TO: &lt;$email&gt;</span>
                    <span class="keyword">try</span>{
                        client.addRecipient(email);
                    }<span class="keyword">catch</span>(Exception e){
                        <span class="keyword">return</span> <span class="keyword">false</span>;
                    }
                    log += <span class="string">"&gt;RCPT TO: &lt;"</span> + email + <span class="string">"&gt;\n"</span>;
                    log += <span class="string">"="</span> + client.getReplyString();

                    <span class="comment">//最后从收件邮箱服务器返回true，说明服务器中能够找到此收件地址，邮箱有效</span>
                    <span class="keyword">if</span> (<span class="number">250</span> == client.getReplyCode()) {
                        <span class="keyword">return</span> <span class="keyword">true</span>;
                    }
                    client.disconnect();

                }
            }
<span class="comment">//            log+=tempLog;</span>
<span class="comment">//            log += "&gt;MAIL FROM: &lt;"+SENDER_EMAIL+"&gt;\n";</span>
<span class="comment">//            log += "=" + client.getReplyString();</span>
<span class="comment">//            </span>
<span class="comment">//            // RCPT TO: &lt;$email&gt;</span>
<span class="comment">//            try{</span>
<span class="comment">//                client.addRecipient(email);</span>
<span class="comment">//            }catch(Exception e){</span>
<span class="comment">//                return false;</span>
<span class="comment">//            }</span>
<span class="comment">//            log += "&gt;RCPT TO: &lt;" + email + "&gt;\n";</span>
<span class="comment">//            log += "=" + client.getReplyString();</span>
<span class="comment">//            </span>
<span class="comment">//            //最后从收件邮箱服务器返回true，说明服务器中能够找到此收件地址，邮箱有效</span>
<span class="comment">//            if (250 == client.getReplyCode()) {</span>
<span class="comment">//                return true;</span>
<span class="comment">//            }</span>
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        } <span class="keyword">finally</span> {
            <span class="keyword">try</span> {
                client.disconnect();
            } <span class="keyword">catch</span> (IOException e) {
            }
            <span class="comment">// print log</span>
            System.out.println(log);
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="comment">/**
     * This method is more accurate than checkEmailMethod(String email);
     * 
     * <span class="doctag">@param</span> email  The recipient's email address, it need to be validate if it is real exists or doesn't exists.
     * <span class="doctag">@return</span> True if email is real exists, false if not.
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkEmail</span><span class="params">(String email)</span></span>{
        <span class="keyword">if</span>(email.split(<span class="string">"@"</span>)[<span class="number">1</span>].equals(<span class="string">"qq.com"</span>)){
            <span class="keyword">if</span>( checkEmailMethod(email) &amp;&amp; checkEmailMethod(email) &amp;&amp; checkEmailMethod(email)){
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }<span class="keyword">else</span>{
                <span class="keyword">return</span> <span class="keyword">false</span>;
            }
        }
        <span class="keyword">return</span> checkEmailMethod(email);
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        CheckEmail ce = <span class="keyword">new</span> CheckEmail();
        <span class="keyword">if</span>(ce.checkEmail(<span class="string">"dfdegcex@qq.com"</span>)){
            System.out.println(<span class="string">"true"</span>);
        }<span class="keyword">else</span>{
            System.out.println(<span class="string">"false"</span>);
        }
    }

}
</code></pre>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其中还写了一点开发过程中的相关文档，生成了该功能相应的jar包。也生成了dll，写了供C#调用的使用方法。很简单。这里附上相关文件的链接：<a href="http://pan.baidu.com/s/1jHpdDjC" target="_blank" rel="external">http://pan.baidu.com/s/1jHpdDjC</a> &nbsp;&nbsp;密码：wio6</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java实现将选择题题库按照字母顺序重新排列]]></title>
      <url>http://www.bluestroy.com/2016/09/10/Java%E5%AE%9E%E7%8E%B0%E5%B0%86%E9%80%89%E6%8B%A9%E9%A2%98%E9%A2%98%E5%BA%93%E6%8C%89%E7%85%A7%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97/</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>记</strong>：若有开卷考试，且只能带纸质题库，而选择题题库又特别多，那么就可以用此方法将题库按照字母顺序排列，便于查找定位。  </p>
</blockquote>
<h3 id="巧用TreeMap"><a href="#巧用TreeMap" class="headerlink" title="巧用TreeMap"></a>巧用TreeMap</h3><p>Java中的Map是用来存储键值对的，其中HashMap没有固定的排列顺序，是通过hashcode对其内容进行快速查找。而TreeMap是由红黑树算法实现的，TreeMap在保存元素是按照key值的顺序排好序的。如果你需要得到一个有序的结果就应该使用TreeMap。TreeMap在不指定排序器时，默认按照key值进行升序排序。  </p>
<p>本方法需要先将题库拷贝到txt文本中（注意txt中\r\n表示一个换行符），取<strong>每道题去掉题号之后的第一行内容作为key，整个题目的内容作为value</strong>，则遍历完所有的题库并将其保存到TreeMap后，TreeMap中的题目就已经是按照A-Za-z的字母顺序排列了(key是字符串的话按照第一个字母的ASCII升序)，将其输出即可。  （A-65，a-97）</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>很简单，一看就懂。  </p>
<pre><code class="java"><span class="keyword">import</span> java.io.*;
<span class="keyword">import</span> java.util.HashMap;
<span class="keyword">import</span> java.util.Iterator;
<span class="keyword">import</span> java.util.TreeMap;
<span class="comment">/*
将选择题题库按照字母顺序重新排列
若有开卷考试，使用排序后的题库进行查找岂不是非常方便。
*/</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException</span>{
        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"tiku.txt"</span>));
        BufferedWriter out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"tiku_sort.txt"</span>));
        TreeMap&lt;String, String&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();
        String s, content = <span class="string">""</span>, key = <span class="string">""</span>;
        s = in.readLine();
        <span class="keyword">int</span> length;
        <span class="keyword">int</span> maxNumber = <span class="number">6</span>;      <span class="comment">//表示一共有多少到题，最大的题号</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxNumber; i++) {
            <span class="keyword">if</span> (s != <span class="keyword">null</span> &amp;&amp; s.startsWith(String.valueOf(i))) {
                key = <span class="string">""</span>;
                content = s + <span class="string">"\r\n"</span>;        <span class="comment">//在txt中\r\n表示一个换行符</span>
                <span class="keyword">if</span> (i &lt; <span class="number">10</span>) {
                    length = <span class="number">2</span>;                <span class="comment">//length表示除题号和.之外的内容开始的下标，用于后面key截取字符串的开始位置</span>
                }
                <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">100</span>) {
                    length = <span class="number">3</span>;
                }
                <span class="keyword">else</span> {
                    length = <span class="number">4</span>;
                }
                key = s.substring(length).replaceAll(<span class="string">" "</span>, <span class="string">""</span>).toLowerCase();    <span class="comment">//将每个题的第一行（去除题号后)作为key，用于排序</span>
                <span class="comment">//System.out.println(key+"-----------");</span>
            }
            <span class="comment">//将一道题的整个内容放入content</span>
            s = in.readLine();
            <span class="keyword">while</span> (s != <span class="keyword">null</span> &amp;&amp; !s.startsWith(String.valueOf((<span class="keyword">int</span>)(i+<span class="number">1</span>)))) {    <span class="comment">//因为题库都是按顺序的，所有这样写（i+1)</span>
                content += s + <span class="string">"\r\n"</span>;
                s = in.readLine();
            }
            <span class="comment">//TreeMap会自动按照键值进行排序建树</span>
            map.put(key, content);
        }

        <span class="comment">//整棵树的内容写到一个新的文件中。新的文件是按字母顺序排列（旧的文件按照题号排序）</span>
        Iterator&lt;String&gt; keys = map.keySet().iterator();
        <span class="keyword">while</span> (keys.hasNext()) {
            key = keys.next();
            content = map.get(key);
            out.write(content);
        }
        <span class="keyword">try</span>{
            in.close();
            out.close();
        }<span class="keyword">catch</span>(Exception e){}

    }
}
</code></pre>
<h3 id="样例输入与输出"><a href="#样例输入与输出" class="headerlink" title="样例输入与输出"></a>样例输入与输出</h3><p><b>1. 样例输入：  </b></p>
<blockquote>
<ol>
<li>d a respon…What.. this behavior?<br>A) Compare the conten…<br>B) Refer to the con…<br>C) Compare the contents of..<br>D) Refer to the ale..  </li>
<li>you decided to…lause? (Choose three.)<br>A. ALL<br>B. PFILE<br>C. BOTH<br>D. NONE  </li>
<li>efine aue… the event?<br>A) the alert.log file<br>B) the DBA_ALERTS view<br>C) the Database Control Home page<br>D) the Database Control performance page<br>E) the Database Control Maintenance page  </li>
</ol>
</blockquote>
<p><b>2. 样例输出： </b></p>
<blockquote>
<ol>
<li>d a respon…What.. this behavior?<br>A) Compare the conten…<br>B) Refer to the con…<br>C) Compare the contents of..<br>D) Refer to the ale..  <ol>
<li>efine aue… the event?<br>A) the alert.log file<br>B) the DBA_ALERTS view<br>C) the Database Control Home page<br>D) the Database Control performance page<br>E) the Database Control Maintenance page</li>
<li>you decided to…lause? (Choose three.)<br>A. ALL<br>B. PFILE<br>C. BOTH<br>D. NONE  </li>
</ol>
</li>
</ol>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[树莓派装系统+远程登录]]></title>
      <url>http://www.bluestroy.com/2016/09/10/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%A3%85%E7%B3%BB%E7%BB%9F-%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>——树莓派？好吃吗？<br>——Yes, It’s delicious, but for programer!  </p>
</blockquote>
<p>树莓派（Raspberry Pi)是只有信用卡卡片大小的微型电脑，系统基于Linux。吃货们要注意了，它是一台电脑，麻雀虽小，五脏可是俱全呢，树莓派是众多计算机发烧友和创客的玩具（价格二三百块钱），你可以用它做出很多令人惊喜而好玩的东西。  </p>
<p>废话不多说了，当你买来树莓派时，它还是一个裸机，需要你给它装系统。  </p>
<h2 id="树莓派装系统"><a href="#树莓派装系统" class="headerlink" title="树莓派装系统"></a>树莓派装系统</h2><ol>
<li>下载2015-05-05-raspbian-wheezy树莓派系统镜像文件</li>
<li>树莓派用SD卡来充当硬盘，用卡器将SD卡连接电脑，使用Win32DiskImager软件把系统镜像文件烧录到SD卡上</li>
<li>然后将SD卡插到树莓派上，把树莓派接通电源，树莓派即启动了。  </li>
</ol>
<p>很简单就将树莓派系统装好了。树莓派启动时，红灯亮、绿灯闪烁，当绿灯常亮时即启动成功。</p>
<blockquote>
<p>一开始因为不是很懂，进入系统后操作失误，后来又重装了系统。<br><strong>注意： </strong>重装系统时要先使用<strong>SDFormatterv4</strong>软件对SD卡进行格式化，如果直接<code>右键-&gt;格式化</code>的话很可能SD的容量没有完全释放掉，格式化后只显示很小的容量。  </p>
</blockquote>
<h2 id="树莓派远程登录"><a href="#树莓派远程登录" class="headerlink" title="树莓派远程登录"></a>树莓派远程登录</h2><p>如果有显示器和HDMI连接线，是可以直接将树莓派连接到显示其上使用的。这里讲一下没有的话要如何远程登录树莓派。</p>
<h3 id="1、获取树莓派的IP地址"><a href="#1、获取树莓派的IP地址" class="headerlink" title="1、获取树莓派的IP地址"></a>1、获取树莓派的IP地址</h3><p><strong>要远程登录树莓派首先要知道树莓派的IP地址：</strong><br>首先将网线插入树莓派，然后使用<strong>Advanced Ip Scanner</strong>软件进行Ip扫描，可以扫描出连接到当前局域网的所有设备。可以看到制造商为<strong>Raspberry Pi Foundation</strong>的设备就是树莓派，IP地址为10.199.157.36，听说树莓派的MAC 地址前几个数是固定的，也可通过Mac地址判断。如果连接的设备较多，可以根据自己的笔记本IP大概判断一下树莓派的IP，然后在软件的输入框中输入IP段范围，可以找的快一点。<br><img src="http://obmxnha1c.bkt.clouddn.com/20151012213447693.jpg" alt="Untitled Image">  </p>
<h3 id="2、使用Win7自带的mstsc远程登录"><a href="#2、使用Win7自带的mstsc远程登录" class="headerlink" title="2、使用Win7自带的mstsc远程登录"></a>2、使用Win7自带的mstsc远程登录</h3><p><code>开始 -&gt; 输入 mstsc</code>，弹出桌面远程连接，输入树莓派的ip地址后点击连接，就可以登录到树莓派系统了，中间要输入树莓派的账密，<code>默认账号：pi 密码：raspberry</code> 。下面是登录后的样子：<br><img src="http://obmxnha1c.bkt.clouddn.com/20151012214540119.jpg" alt="Untitled Image">  </p>
<h3 id="3、其他技巧"><a href="#3、其他技巧" class="headerlink" title="3、其他技巧"></a>3、其他技巧</h3><ul>
<li>我试了一下远程登录可以好几台电脑同时远程登录树莓派，互相之间操作的结果会同步，但其他人的操作动作不可见  </li>
<li>mstsc远程登录可以使用<code>ctrl+alt+Break</code>快捷键进行全盘切换，当键盘不灵时也可以切换一下就可以了</li>
<li>另外：也可以用<strong>ssh+putty</strong>进行远程登录  </li>
</ul>
<h2 id="树莓派无线网卡配置"><a href="#树莓派无线网卡配置" class="headerlink" title="树莓派无线网卡配置"></a>树莓派无线网卡配置</h2><p>如果是连接的路由器的wifi的话，这个百度经验上有，自行百度。<br><strong>注意</strong>：如果无线网卡配置信息过时或错误，同时插上无线网卡和网线远程登录可能会有问题，也可能上不了网，这个时候把无线网卡拔掉，直插网线就好。<br>【配置没成功，待定】</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux Makefile文件编译错误——makeNothing to be done for 'all']]></title>
      <url>http://www.bluestroy.com/2016/09/10/Linux%20Makefile%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E2%80%94%E2%80%94makeNothing%20to%20be%20done%20for%20'all'/</url>
      <content type="html"><![CDATA[<h4 id="错误出现"><a href="#错误出现" class="headerlink" title="错误出现"></a>错误出现</h4><p>在Linux操作系统中使用Makefile时，Makefile内容如下：  </p>
<p><img src="http://obmxnha1c.bkt.clouddn.com/20160102232834116.png" alt="Untitled Image"></p>
<p>然后make进行编译，出现如下错误：make： Nothing to be done for ‘all’  </p>
<p><img src="http://obmxnha1c.bkt.clouddn.com/20160102232950093.png" alt="Untitled Image">  </p>
<p>在网上查了半天找不到解决方法，网上大多是转来转去的同一个说法。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>Makefile文件中只能使用Tab，不能使用多个空格。这个Makefile文件的内容是复制来的，所以图片上白色高亮区域是多个空格，把它变为一个tab就可以了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://www.bluestroy.com/2016/08/08/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
